// {{ autogen_marker }}
{%- import "/macros.proto.j2" as macros %}

#pragma once

#include <{{ client_misc_lib }}/enums.h>
#include <{{ client_misc_lib }}/schema_transitive.h>

#include <yt/yt/orm/server/master/public.h>

#include <yt/yt/orm/server/objects/public.h>
#include <yt/yt/orm/server/objects/semaphore_detail.h>
#include <yt/yt/orm/server/objects/semaphore_set_detail.h>

#include <yt/yt/orm/library/mpl/types.h>

#include <library/cpp/yt/memory/ref_counted.h>

{%- if objects | selectattr("custom_cpp_object") | list | length > 0 %}
namespace {{ cpp_server_plugins_namespace }} {

////////////////////////////////////////////////////////////////////////////////

{%- for object in objects if object.custom_cpp_object %}
class T{{ object.camel_case_name }};
{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

} // {{ cpp_server_plugins_namespace }}
{%- endif %}

namespace {{ cpp_server_namespace }} {

////////////////////////////////////////////////////////////////////////////////

DECLARE_REFCOUNTED_CLASS(TMasterConfig)
DECLARE_REFCOUNTED_CLASS(TMasterDynamicConfig)

{%- if not custom_dynamic_config_manager %}
DECLARE_REFCOUNTED_STRUCT(IDynamicConfigManager)
{%- endif %}

{%- if cpp_server_namespace != cpp_objects_namespace %}

////////////////////////////////////////////////////////////////////////////////

} // namespace {{cpp_server_namespace}}

////////////////////////////////////////////////////////////////////////////////

namespace {{ cpp_objects_namespace }} {
{%- endif %}

////////////////////////////////////////////////////////////////////////////////
{{ macros.line_break() }}
{%- for object in objects %}
class T{{ object.camel_case_name }};
{%- endfor %}

using TFinalSemaphore = NYT::NOrm::NServer::NObjects::TSemaphoreMixin<TSemaphore, {{ cpp_data_model_proto_namespace }}::TSemaphore>;
using TFinalSemaphoreSet = NYT::NOrm::NServer::NObjects::TSemaphoreSetMixin<
    TSemaphoreSet,
    TFinalSemaphore,
    {{ cpp_data_model_proto_namespace }}::TSemaphoreSet,
    {{ cpp_data_model_proto_namespace }}::TSemaphore
>;

////////////////////////////////////////////////////////////////////////////////

using TObjectTypes = NYT::NOrm::NMpl::TTypes<
{%- for object in objects %}
    T{{ object.camel_case_name }}{% if not loop.last %},{% else %}>;{% endif %}
{%- endfor %}

template <class T>
concept CObjectType = NYT::NOrm::NMpl::COneOfTypes<T, TObjectTypes>;

//! Helper to get ObjectType by runtime enum type.
//! TInvokable must have signature `void <typename T>()`,
template <NYT::NOrm::NMpl::CInvocableForEachType<TObjectTypes> TInvokable>
bool InvokeForObjectType(NYT::NOrm::NClient::NObjects::TObjectTypeValue objectTypeValue, TInvokable&& consumer)
{
    bool found = false;
    TObjectTypes::ForEach([&] <CObjectType T> {
        if (T::Type == objectTypeValue) {
            found = true;
            consumer.template operator()<T>();
        }
    });
    return found;
}

////////////////////////////////////////////////////////////////////////////////

using {{ client_misc_cpp_namespace }}::EObjectType;

{%- for enum in public_enums | sort(attribute='name') %}
using {{ client_misc_cpp_namespace }}::{{enum.name}};
{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

} // namespace {{ cpp_objects_namespace }}
