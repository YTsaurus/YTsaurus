// {{ autogen_marker }}
{%- import "/macros.proto.j2" as macros %}

#include "{{ object.snake_case_name }}_type_handler.h"

{% if not yp_compatible -%}
#include "db_schema.h"
#include "object_detail.h"
{%- else -%}
#include <yp/server/master/objects/db_schema.h>
{%- endif %}
{%- if object.foreign_objects %}
{##}
{%-for o in object.foreign_objects %}
{%-if (dont_skip_cpp or not o.skip_cpp) and not o.custom_cpp_object %}
#include "{{ o.snake_case_name }}.h"
{%- else %}
#include <{{ cpp_server_plugins_path }}/{{ o.snake_case_name }}.h>
{%- endif %}
{%- endfor %}
{%- endif %}

{%- if object.custom_cpp_object %}
{##}
#include <{{ cpp_server_plugins_path }}/{{ object.snake_case_name }}.h>
{%- endif %}

#include <yt/yt/orm/server/master/bootstrap.h>

#include <yt/yt/orm/server/objects/attribute_schema.h>
#include <yt/yt/orm/server/objects/build_tags.h>
#include <yt/yt/orm/server/objects/type_handler.h>
#include <yt/yt/orm/server/objects/watch_log.h>

{%- if object.builtin %}
#include <yt/yt/orm/server/objects/{{ object.snake_case_name }}_type_handler_detail.h>
{%- endif %}

#include <yt/yt/orm/client/objects/registry.h>

{%- if cpp_server_plugins_namespace %}

namespace {{ cpp_server_plugins_namespace }} {

////////////////////////////////////////////////////////////////////////////////

std::unique_ptr<NYT::NOrm::NServer::NObjects::IObjectTypeHandler>
Create{{ object.camel_case_name }}TypeHandler(
    NYT::NOrm::NServer::NMaster::IBootstrap* bootstrap,
    NYT::NOrm::NServer::NObjects::TObjectManagerConfigPtr config);

////////////////////////////////////////////////////////////////////////////////

} // namespace {{ cpp_server_plugins_namespace }}

{%- endif %}

namespace {{ cpp_objects_namespace }} {

////////////////////////////////////////////////////////////////////////////////

using NYT::NOrm::NServer::NMaster::IBootstrap;
using NYT::NOrm::NServer::NObjects::IObjectTypeHandler;
using NYT::NOrm::NServer::NObjects::ISession;
using NYT::NOrm::NServer::NObjects::TTagSet;
using NYT::NOrm::NServer::NObjects::TObjectFilter;
using NYT::NOrm::NServer::NObjects::ESetUpdateObjectMode;

using TDBFields = std::vector<const NYT::NOrm::NServer::NObjects::TDBField*>;

{% macro foreign_object_name(field) -%}
{%- if field.reference_deprecated -%}
    {{ field.reference_deprecated.foreign_object.camel_case_name }}
{%- elif field.reference -%}
    {{ field.reference.foreign_object.camel_case_name }}
{%- elif field.transitive_reference -%}
    {{ field.transitive_reference.foreign_object.camel_case_name }}
{%- else -%}
    {{ raise("No reference provided for field " + field.snake_case_name) }}
{%- endif -%}
{%- endmacro %}

{%- macro generation_policy(field, message_path, schema_name=none) -%}
    {%- if field.has_custom_policy -%}
        ->SetCustomPolicyExpected()
    {%- else -%}
        {%- if field.is_primary -%}
        ->SetKeyFieldPolicy(
        {%- else -%}
        ->SetPolicy({{ schema_name }},
        {%- endif %}
        {%- if field.cpp_type == "TString" %}
            NYT::NOrm::NServer::NObjects::CreateStringAttributePolicy(
                NYT::NOrm::NServer::NObjects::EAttributeGenerationPolicy::{{ field.generation_policy }},
                {{ field.min_length if field.min_length else "NYT::NOrm::NServer::NObjects::DefaultMinStringAttributeLength"}},
                {{ field.max_length if field.max_length else "NYT::NOrm::NServer::NObjects::DefaultMaxStringAttributeLength"}},
                {{ field.valid_charset if field.valid_charset else "NYT::NOrm::NServer::NObjects::DefaultStringAttributeValidChars"}})
        {%- else %}
            NYT::NOrm::NServer::NObjects::CreateIntegerAttributePolicy<{{ field.cpp_type }}>(
                NYT::NOrm::NServer::NObjects::EAttributeGenerationPolicy::{{ field.generation_policy }},
                GetBootstrap(),
            {%- if field.min_value %}
                {{ field.min_value }}
            {%- else %}
                NYT::NOrm::NServer::NObjects::DefaultMinIntegerAttributeValue<{{ field.cpp_type }}>
            {%- endif -%},
            {%- if field.max_value %}
                {{ field.max_value }}
            {%- else %}
                NYT::NOrm::NServer::NObjects::DefaultMaxIntegerAttributeValue<{{ field.cpp_type }}>
            {%- endif -%},
                NYT::NOrm::NServer::NObjects::TAttributePolicyOptions{
                    .Type = GetType(),
                    .AttributePath = "{{ message_path }}/{{ field.snake_case_name }}",
                    .IndexForIncrement = "{{ field.index_for_increment if field.index_for_increment}}"
                })
        {%- endif %})
    {%- endif %}
{%- endmacro %}

{%- macro schema_name(class_name, field) -%}
    {{ class_name }}::{{ field.cpp_camel_case_name }}Descriptor
{%- endmacro %}

{%- macro field_properties(field, superuser_only, message_path=none, schema_name=none) -%}
{%- if field.generation_policy %}
    {{ generation_policy(field, message_path, schema_name) | indent(4) }}
{%- endif %}
{%- if field.update_policy %}
    ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::{{ field.update_policy }})
{%- else %}
    {%- if superuser_only %}
    ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::ReadOnly)
    {%- endif %}
{%- endif %}
{%- if field.opaque %}
    ->SetOpaque({% if not field.emit_opaque_as_entity %}/*emitEntity*/ false{% endif %})
{%- endif %}
{%- if field.mandatory %}
    ->SetMandatory()
{%- endif %}
{%- endmacro %}

{%- macro object_tags_tree(node) %}
{
{%- if node.children %}
    .Children = {
    {%- for name, child in node.children.items() %}
        {
            "{{ name }}",
            {{- object_tags_tree(child) | indent(12) }}
        },
    {%- endfor %}
    },
{%- endif %}
{%- if node.etc_name %}
    .EtcName = "{{ node.etc_name }}",
{%- endif %}
{%- if node.etc %}
    .Etc = true,
{%- endif %}
{%- if node.repeated %}
    .Repeated = true,
{%- endif %}
{%- if node.tags %}
    .Tags = TTagSet({ {{ node.formatted_tags }} }),
{%- endif %}
}
{%- endmacro %}

{%- macro control_touch(object, field_name, cpp_data_model_proto_namespace) %}
->SetControl<T{{ object.camel_case_name }}, NYT::NOrm::NDataModel::TObjectTouch>(
    [] (NYT::NOrm::NServer::NObjects::TTransaction* transaction,
        T{{ object.camel_case_name }}* object,
        const auto& touch)
    {
        if (touch.lock_removal()) {
            auto* session = transaction->GetSession();
            session->ScheduleStore(
                [object] (NYT::NOrm::NServer::NObjects::IStoreContext* context) {
                    auto* typeHandler = object->GetTypeHandler();
                    // Lock is taken to prevent success of concurrent RemoveObject query.
                    // Without it, no write set would be added and
                    // `RemoveObject` may be committed before `/control/touch` update.
                    context->LockRow(
                        typeHandler->GetTable(),
                        typeHandler->GetObjectTableKey(object),
                        std::array{&NYT::NOrm::NServer::NObjects::ObjectsTable.Fields.ExistenceLock},
                        NYT::NTableClient::ELockType::SharedStrong);
                });
        }
        if (touch.store_event_to_history()) {
            {%- if not object.add_touch_history %}
            THROW_ERROR_EXCEPTION("History is disabled for %v",
                object->GetDisplayName());
            {%- endif %}
            object->ControlTouchEventsToSave().insert("{{ field_name }}");
        }
    }),
{%- endmacro %}

{%- macro fields(object, message, field_names, message_path, update_policy="") -%}
    {%- set class_name -%}
        T{{([object.camel_case_name] + field_names) | join("::T")}}
    {%- endset %}
    {%- set superuser_only = message.attributes_updatable_by_superuser_only -%}
    {%- if message.is_cpp_composite %}
        ->AddChildren({
        {%- for field in message.composite_fields %}
            MakeCompositeAttributeSchema("{{ field.snake_case_name }}")
            {{- fields(object, field.value_message, field_names + [field.camel_case_name], message_path + "/" + field.snake_case_name, field.update_policy) | indent(8) }}
            {{- field_properties(field, superuser_only, message_path) | indent(12) }},
        {%- endfor %}
        {%- for field in message.column_fields if not field.is_timestamp_attribute %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", {{ schema_name(class_name, field) }})
            {{- field_properties(field, superuser_only, message_path, schema_name(class_name, field)) | indent(12) }},
        {%- endfor %}
        {%- set etcs = message.etcs -%}
        {%- for etc in etcs %}
            MakeEtcAttributeSchema({% if etc.name | length > 0 %}"{{ etc.name }}", {% endif %}{{ class_name }}::{{ etc.camel_case_name }}EtcDescriptor)
                {%- if message.mandatory %}
                ->SetMandatory()
                {%- endif %}
                {%- if superuser_only %}
                ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::ReadOnly)
                {%- endif %}
            {%- for field in etc.fields | selectattr("update_policy") %}
                ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::{{field.update_policy}}, "/{{field.snake_case_name}}")
            {%- endfor %}
            {%- for field in etc.fields | selectattr("mandatory") %}
                ->SetMandatory("{{field.snake_case_name}}")
            {%- endfor %},

        {%- endfor %}
        {%- for field in message.reference_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", {{ schema_name(class_name, field) }}),
        {%- endfor %}
        {%- for field in message.view_fields_deprecated %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", {{ schema_name(class_name, field) }}),
        {%- endfor %}
        {%- for field in message.view_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", {{ schema_name(class_name, field) }}),
        {%- endfor %}
        {%- for field in message.children_view_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", {{ schema_name(class_name, field) }}),
        {%- endfor %}
        {%- for field in message.computed_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}")
                ->SetComputed()
                {{- field_properties(field, superuser_only, message_path) | indent(12) }},
        {%- endfor %}
        })
        {%- if message.force_overwrite_update_mode %}
        ->SetUpdateMode(ESetUpdateObjectMode::Overwrite)
        {%- endif %}
        {%- if update_policy %}
        ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::{{ update_policy }})
        {%- else %}
        {%- endif %}
        {%- if message.extensible %}
        ->SetExtensible()
        {%- endif %}
    {%- else %}
        // TODO(kmokrov): Add generation policy https://st.yandex-team.ru/YTORM-686.
        ->SetAttribute(T{{ object.camel_case_name }}::{{ field_names | last }}Descriptor)
        {%- if superuser_only %}
        ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::ReadOnly)
        {%- endif %}
        {%- if message.mandatory %}
        ->SetMandatory()
        {%- endif %}
        {%- if message.extensible %}
        ->SetExtensible()
        {%- endif %}
    {%- endif %}
{%- endmacro %}

{%- macro generate_indexed_attribute_descriptor(index, attributes) -%}
    std::vector<NYT::NOrm::NServer::NObjects::TIndexedAttributeDescriptor>{
        {%- for attribute in attributes %}
        NYT::NOrm::NServer::NObjects::TIndexedAttributeDescriptor(
            &T{{ index.object_type_camel_case_name }}
                {%- if attribute.column_field.is_column -%}
                    {%- if attribute.column_field.parent.cpp_object_field_name != "Meta" -%}
                        {%- for field in attribute.prefix_fields -%}
                            ::T{{ field.camel_case_name }}
                        {%- endfor -%}
                    {%- endif -%}
                    ::{{ attribute.column_field.cpp_camel_case_name }}Descriptor
                {%- elif attribute.column_field.value_message.has_etc -%}
                    {%- if attribute.column_field.value_message.cpp_object_field_name != "Meta" -%}
                        ::T{{ attribute.column_field.value_message.cpp_object_field_name }}::EtcDescriptor
                    {%- else -%}
                        ::MetaEtcDescriptor
                    {%- endif -%}
                {%- else -%}
                    ::{{ attribute.column_field.parent.cpp_object_field_name }}Descriptor
                {%- endif -%},
            "{{ attribute.suffix }}"),
        {%- endfor %}
    }
{%- endmacro -%}

    {%- set superuser_only = database_options.meta_attributes_updatable_by_superuser_only or object.meta.attributes_updatable_by_superuser_only -%}

T{{ object.camel_case_name }}TypeHandler::T{{ object.camel_case_name }}TypeHandler(
    IBootstrap* bootstrap,
    NYT::NOrm::NServer::NObjects::TObjectManagerConfigPtr config)
    : TBase(
        bootstrap,
    {%- if not yp_compatible %}
        static_cast<NYT::NOrm::NClient::NObjects::TObjectTypeValue>(EObjectType::{{ object.camel_case_name }}))
    {%- else %}
        TObjectTypeValues::{{ object.camel_case_name }})
    {%- endif %}
    , Config_(std::move(config))
    , KeyFields_({
    {%- for field in object.key_fields %}
        &{{ object.table_cpp_name }}.{{ field.column.full_cpp_name }}{{ "," if not loop.last else "})" }}
    {%- endfor %}
{%- if object.parent %}
    , ParentKeyFields_({
    {%- for field in object.all_key_fields | selectattr("is_parent_key_field") %}
        &{{ object.table_cpp_name }}.{{ field.column.full_cpp_name }}{{ "," if not loop.last else "})" }}
    {%- endfor %}
{%- endif %}
{%- if object.access_control_parent %}
    , AccessControlParentKeyFields_({
    {%- for field in object.meta.column_fields | selectattr("is_access_control_parent") %}
        &{{ object.table_cpp_name }}.{{ field.column.full_cpp_name }}{{ "," if not loop.last else "})" }}
    {%- endfor %}
{%- endif %}
    , NullKey_({{ object.null_key_constructor_params }})
{ }
{%- if object.custom_type_handler %}

T{{ object.camel_case_name }}TypeHandler::~T{{ object.camel_case_name }}TypeHandler()
{ }
{%- endif %}

void T{{ object.camel_case_name }}TypeHandler::Initialize()
{
    TBase::Initialize();

{%- if object.forbid_parent_removal %}

    ForbidParentRemoval_ = true;
{%- endif %}
{##}
{%- if not yp_compatible %}
    MetaAttributeSchema_
        ->AddChildren({
        MakeScalarAttributeSchema("acl", TDataModelObject::AclDescriptor)
            ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::Updatable)
            ->AddValidator<NYT::NOrm::NServer::NObjects::TObject>(std::bind_front(
                &T{{ object.camel_case_name }}TypeHandler::ValidateAcl, this))
    });
{%- endif %}
    MetaAttributeSchema_
        ->AddChildren({
{%- if object.parent %}
    {%- for field in object.all_key_fields | selectattr("is_parent_key_field") %}
            MakeParentIdAttributeSchema(
                "{{ object.parent | foreign_key_prefix }}_{{ field.snake_case_name }}",
                &{{ object.table_cpp_name }}.{{ field.column.full_cpp_name }},
                MakeValueGetter(&T{{ object.camel_case_name }}::{{ object.parent.camel_case_foreign_name }}{{ field.camel_case_name }})),
    {%- endfor %}
{%- endif %}
{%- for field in object.key_fields %}
            MakeIdAttributeSchema(
                "{{ field.snake_case_name }}",
                &{{ object.table_cpp_name }}.{{ field.column.full_cpp_name }},
                MakeValueGetter(&T{{ object.camel_case_name }}::Get{{ field.camel_case_name }}))
                {{ generation_policy(field, "/meta") | indent(8) }},
{%- endfor %}
{%- set superuser_only = database_options.meta_attributes_updatable_by_superuser_only or object.meta.attributes_updatable_by_superuser_only %}
{%- for field in object.meta.fields | rejectattr("is_primary") | selectattr("is_column") | rejectattr("system") | rejectattr("is_parent_key_field") %}
        {%- set schema_name -%}
            T{{ object.camel_case_name }}::{{ field.cpp_camel_case_name }}Descriptor
        {%- endset %}
            {{ "MakeAccessControlParentIdAttributeSchema" if field.is_access_control_parent else "MakeScalarAttributeSchema" -}}
            ("{{ field.snake_case_name }}", {{ schema_name }})
            {{- field_properties(field, superuser_only) | indent(12) }}
        {%- if field.store_field_to_meta_response %}
                ->EnableMetaResponseAttribute()
        {%- endif %},
{%- endfor %}
{%- for field in object.meta.reference_fields + object.meta.view_fields_deprecated + object.meta.view_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}", T{{ object.camel_case_name }}::{{ field.cpp_camel_case_name }}Descriptor),
{%- endfor %}
{%- for field in object.meta.computed_fields %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}")
                ->SetComputed()
                {{- field_properties(field, superuser_only) | indent(12) }},
{%- endfor %}
            TBase::MakeEtcAttributeSchema(T{{ object.camel_case_name }}::MetaEtcDescriptor.AddValidator(
                std::bind_front(&T{{ object.camel_case_name }}TypeHandler::ValidateMetaEtcOnValueUpdate, this)))
                ->SetUpdatePolicy(NYT::NOrm::NServer::NObjects::EUpdatePolicy::Updatable)
                ->template AddValidator<T{{ object.camel_case_name }}>(std::bind_front(
                    &T{{ object.camel_case_name }}TypeHandler::ValidateMetaEtcOnTransactionCommit, this))
                {%- for field in object.meta.fields | selectattr("mandatory") | rejectattr("is_column") %}
                ->SetMandatory("{{field.snake_case_name}}")
                {%- endfor %}
            });

    SpecAttributeSchema_
        {{- fields(object, object.spec, ["Spec"], "/spec") }};

    StatusAttributeSchema_
        {{- fields(object, object.status, ["Status"], "/status") }};

    {%- for tracker in object.revision_trackers %}
    PrepareRevisionTracker(
        /*trackedPaths*/ {
            {%- for tracked_path in tracker.tracked_paths %}
            "{{ tracked_path }}",
            {%- endfor %}
        },
        /*trackerPath*/ "{{ tracker.path }}",
        /*lockGroupRestrictionEnabled*/ {{ tracker.lock_group_restriction_enabled | to_cpp_bool }}
        {%- if tracker.excluded_attributes -%}
        ,
        /*excludedPaths*/ {
            {%- for excluded_field in tracker.excluded_attributes %}
            "{{ excluded_field.full_path }}",
            {%- endfor %}
        }
        {%- endif -%});
    {%- endfor %}

    {%- for geo_info in object.hashed_geo_points %}
    PrepareGeoPoints(
        /*geoPointPath*/ "{{ geo_info.geo_point.path }}",
        /*geoHashPath*/ "{{ geo_info.geohash_field.path }}",
        /*geoHashLength*/ {{ geo_info.geohash_length }});
    {%- endfor %}

    ControlAttributeSchema_
        ->AddChildren({
    {%- for field in object.control.direct_fields %}
    {%- if field.is_control_touch and field.snake_case_name != "touch" %}
            MakeScalarAttributeSchema("{{ field.snake_case_name }}")
            {{- control_touch(object, field.snake_case_name, cpp_data_model_proto_namespace) | indent(4 * 4) }}
    {%- endif %}
    {%- endfor %}
            MakeScalarAttributeSchema("touch")
            {{- control_touch(object, "touch", cpp_data_model_proto_namespace) | indent(4 * 4) }}
    {%- if object.indexes %}
            MakeScalarAttributeSchema("touch_index")
                ->SetControl<T{{ object.camel_case_name }}, NYT::NOrm::NDataModel::TObjectTouchIndex>(
                [] (NYT::NOrm::NServer::NObjects::TTransaction* /*transaction*/,
                    T{{ object.camel_case_name }}* object,
                    const NYT::NOrm::NDataModel::TObjectTouchIndex& touchIndex)
                {
                    for (const auto& indexName : touchIndex.index_names()) {
                        object->GetIndexOrThrow(indexName)->TouchIndex();
                    }
                }),
    {%- endif %}
    {%- if object.has_embedded_semaphores %}
            MakeCompositeAttributeSchema("embedded_semaphore")
                ->AddChildren({
                    MakeScalarAttributeSchema("acquire")
                        ->template SetControlWithTransactionCallContext<
                            NYT::NOrm::NServer::NObjects::TObject, NDataModel::TSemaphoreAcquire>(
                            &NYT::NOrm::NServer::NObjects::NSemaphores::EmbeddedAcquire<
                                NDataModel::TEmbeddedSemaphore, NDataModel::TSemaphoreAcquire>),
                    MakeScalarAttributeSchema("ping")
                        ->template SetControlWithTransactionCallContext<
                            NYT::NOrm::NServer::NObjects::TObject, NDataModel::TSemaphorePing>(
                            &NYT::NOrm::NServer::NObjects::NSemaphores::EmbeddedPing<
                                NDataModel::TEmbeddedSemaphore, NDataModel::TSemaphorePing>),
                    MakeScalarAttributeSchema("release")
                        ->template SetControlWithTransactionCallContext<
                            NYT::NOrm::NServer::NObjects::TObject, NDataModel::TSemaphoreRelease>(
                            &NYT::NOrm::NServer::NObjects::NSemaphores::EmbeddedRelease<
                                NDataModel::TEmbeddedSemaphore, NDataModel::TSemaphoreRelease>),
                }),
    {%- endif %}
    {%- if object.revision_trackers %}
            MakeScalarAttributeSchema("touch_revision")
                ->SetControlWithTransactionCallContext<T{{ object.camel_case_name }}, NYT::NOrm::NDataModel::TObjectTouchRevision>(
                    [&] (NYT::NOrm::NServer::NObjects::TTransaction* transaction,
                        T{{ object.camel_case_name }}* object,
                        const NYT::NOrm::NDataModel::TObjectTouchRevision& touchRevision,
                        const NYT::NOrm::NServer::NObjects::TTransactionCallContext& transactionCallContext)
                    {
                        if (touchRevision.has_path() && !touchRevision.path().empty()) {
                            if (!RevisionTrackerOptionsByPath_.contains(touchRevision.path())) {
                                THROW_ERROR_EXCEPTION("Error running /control/touch_revision: %Qv is not a valid revision path",
                                    touchRevision.path());
                            }
                            auto resolveResult = NYT::NOrm::NServer::NObjects::ResolveAttribute(
                                object->GetTypeHandler(),
                                touchRevision.path(),
                                /*callback*/ {},
                                /*validateProtoSchemaCompliance*/ false);
                            auto* schema = resolveResult.Attribute->AsScalar();
                            THROW_ERROR_EXCEPTION_UNLESS(schema->HasValueSetter(),
                                "Error running /control/touch_revision: Resolved schema does not have a value setter")
                            schema->RunValueSetter(
                                transaction,
                                object,
                                /*path*/ "",
                                NYT::NYTree::ConvertToNode(transaction->GetStartTimestamp()),
                                /*recursive*/ false,
                                /*sharedWrite*/ std::nullopt,
                                /*aggregateMode*/ NYT::NOrm::NServer::NObjects::EAggregateMode::Unspecified,
                                transactionCallContext);
                        } else {
                            THROW_ERROR_EXCEPTION("Error running /control/touch_revision: empty path is given");
                        }
                    }),
    {%- endif %}
    {%- if object.attribute_migrations %}
            MakeScalarAttributeSchema("migrate_attributes")
                ->SetControl<T{{ object.camel_case_name }}, NYT::NOrm::NDataModel::TObjectMigrateAttributes>(
                [] ([[maybe_unused]] NYT::NOrm::NServer::NObjects::TTransaction* transaction,
                    T{{ object.camel_case_name }}* object,
                    const auto& migrateAttributes)
                {
                    static const THashMap<NYT::NYPath::TYPath, int> AttributeMigrationByPath {
                        {%- for attribute_migration in object.attribute_migrations %}
                        {
                            "{{ attribute_migration.target.full_path }}",
                            static_cast<int>(T{{ object.camel_case_name }}::EAttributeMigrations::
                            {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                            {{- macros.attribute_camel_case_name(attribute_migration.target) }})
                        },
                        {%- endfor %}
                    };

                    for (const auto& path : migrateAttributes.target_paths()) {
                        auto it = AttributeMigrationByPath.find(path);
                        THROW_ERROR_EXCEPTION_IF(it == AttributeMigrationByPath.end(),
                            NYT::NOrm::NClient::EErrorCode::InvalidRequestArguments,
                            "Unknown migration target attribute %Qv",
                            path);
                        object->ForceMigrateAttribute(it->second);
                        object->GetSession()->GetOwner()->ScheduleCommitAction(
                            NYT::NOrm::NServer::NObjects::TCommitActionTypes::HandleAttributeMigrations,
                            object);
                    }
                }),

    {%- endif %}
        });

    {%- for index in object.indexes %}
    RegisterScalarAttributeIndex(
        "{{ index.snake_case_name }}",
        std::make_unique<NYT::NOrm::NServer::NObjects::TScalarAttributeIndexDescriptor>(
            "{{ index.snake_case_name }}",
            &{{ index.underlying_table if index.underlying_table else index.camel_case_name }}Table,
            {{ generate_indexed_attribute_descriptor(index, index.index_attributes) | indent(8) }},
            {{ generate_indexed_attribute_descriptor(index, index.predicate_attributes) | indent(8) }},
            /*repeated*/ {{ index.is_repeated | to_cpp_bool }},
            Config_->TryGetIndexMode("{{ index.snake_case_name }}")
                .value_or(NYT::NOrm::NServer::NObjects::EIndexMode::{{ index.mode.value }})
            {%- if index.predicate %},
            {%- set attributes_paths -%}
                { {{- index.predicate_attributes | map(attribute="full_path") | map("tojson") | join(", ") -}} }
            {%- endset %}
            NYT::NOrm::NServer::NObjects::TPredicateInfo{
                .Expression = "{{ index.predicate | replace("\"", "\\\"") }}",
                .AttributesToValidate = {{ attributes_paths }}
            }
            {%- endif %}));
    {%- endfor %}

    {%- for path, attribute_sensor in object.attribute_sensors.items() %}
    AddAttributeSensor("{{ path }}", NYT::NOrm::NClient::NProto::EAttributeSensorPolicy({{ attribute_sensor.policy }}));
    {%- endfor %}

    {%- for child in object.children %}
    RegisterChildrenAttribute(
        {%- if not yp_compatible %}
        static_cast<NYT::NOrm::NClient::NObjects::TObjectTypeValue>(EObjectType::{{ child.camel_case_name }}),
        {%- else %}
        TObjectTypeValues::{{ child.camel_case_name }},
        {%- endif %}
        [] (const NYT::NOrm::NServer::NObjects::TObject* object) {
            return &object->As<T{{ object.camel_case_name }}>()->{{ child | collective_foreign_name }}();
        });
    {%- endfor %}

    {%- for attribute_migration in object.attribute_migrations %}
    ResolveAttribute("{{ attribute_migration.source.full_path }}", {}, true).Attribute
        ->AsScalar()
        ->AddUpdateHandler<T{{ object.camel_case_name }}>(
            [] (NYT::NOrm::NServer::NObjects::TTransaction* /*transaction*/, T{{ object.camel_case_name }}* object) {
                object->MigrateAttribute(static_cast<int>(T{{ object.camel_case_name }}::EAttributeMigrations::
                    {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                    {{- macros.attribute_camel_case_name(attribute_migration.target) }}));
                object->GetSession()->GetOwner()->ScheduleCommitAction(
                    NYT::NOrm::NServer::NObjects::TCommitActionTypes::HandleAttributeMigrations,
                    object);
            });
        {%- if attribute_migration.reverse_write %}
    ResolveAttribute("{{ attribute_migration.target.full_path }}", {}, true).Attribute
        ->AsScalar()
        ->AddUpdateHandler<T{{ object.camel_case_name }}>(
            [] (NYT::NOrm::NServer::NObjects::TTransaction* /*transaction*/, T{{ object.camel_case_name }}* object) {
                object->MigrateAttribute(static_cast<int>(T{{ object.camel_case_name }}::EAttributeMigrations::
                    {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                    {{- macros.attribute_camel_case_name(attribute_migration.target) }}));
                object->GetSession()->GetOwner()->ScheduleCommitAction(
                    NYT::NOrm::NServer::NObjects::TCommitActionTypes::HandleAttributeMigrations,
                    object);
            });
        {%- endif %}
    {%- endfor %}
}
{%- if object.enable_tags %}

static const NYT::NOrm::NServer::NObjects::TTagsTreeNode {{ object.camel_case_name }}TagsTree{{ object_tags_tree(object.tags_tree) }};
{%- endif %}

void T{{ object.camel_case_name }}TypeHandler::PostInitialize()
{
    // History is configured in PostInitialize stage, as users may add some evaluated fields via plugins in Initialize stage.
    // NB: Called before TBase::PostInitialize as base type handler prepares cache.
    ConfigureHistory(
        /*attributes*/ {
        {%- for history_attribute in object.history.attributes %}
            THistoryAttribute{
                .Path = "{{ history_attribute.path }}",
                .Indexed = {{ history_attribute.indexed | to_cpp_bool }},
                {%- if history_attribute.allowed_in_filter %}
                .AllowedInFilter = true,
                {%- endif %}
            },
        {%- endfor %}});

    TBase::PostInitialize();

    // NB: Called after TBase::PostInitialize because filter construction requires type inference.
    ConfigureHistoryFilter({{ "TObjectFilter{.Query = " + object.history.filter | quote + "}" if object.history.filter else "std::nullopt" }});

{%- for field in object.meta.fields %}
    {%- if "store_field_to_meta_response" in field.allow_mixin_overwrite_options and not field.store_field_to_meta_response %}
    if (auto found = MetaAttributeSchema_->FindChild("{{field.snake_case_name}}"); found) {
        found->EnableMetaResponseAttribute(false);
    }
    {%- endif %}
{%- endfor %}
{%- for etc in object.meta.etcs %}
    {%- for field in etc.fields %}
    {%- if "store_field_to_meta_response" in field.allow_mixin_overwrite_options and not field.store_field_to_meta_response %}
    if (auto found = MetaAttributeSchema_->FindEtcChildByFieldName("{{ field.snake_case_name }}"); found) {
        MetaAttributeSchema_->DisableEtcFieldToMetaResponse("{{ field.snake_case_name }}");
    }
    {%- endif %}
    {%- endfor %}
{%- endfor %}

    {%- if object.enable_tags %}
    BuildAttributeSchemaTags(
        RootAttributeSchema_,
        {{ object.camel_case_name }}TagsTree);
    {%- endif %}

    FillUpdatePolicies();
}

bool T{{ object.camel_case_name }}TypeHandler::IsObjectNameSupported() const
{
    return {{ object.name_supported | to_cpp_bool }};
}

bool T{{ object.camel_case_name }}TypeHandler::SkipStoreWithoutChanges() const
{
    return {{ object.skip_store_without_changes | to_cpp_bool }};
}

bool T{{ object.camel_case_name }}TypeHandler::ForceZeroKeyEvaluation() const
{
    return {{ object.force_zero_key_evaluation | to_cpp_bool }};
}

std::vector<NYT::NOrm::NServer::NObjects::TWatchLog>
T{{ object.camel_case_name }}TypeHandler::GetWatchLogs() const
{
    return std::vector<NYT::NOrm::NServer::NObjects::TWatchLog>{
    {%- for watch_log in object.watch_logs %}
        NYT::NOrm::NServer::NObjects::TWatchLog{
            .ObjectName = "{{ object.snake_case_name }}",
            .Name = "{{ watch_log.snake_case_name }}",
            .Filter{
                .Query{
                    "{{ watch_log.filter }}"
                }
            },
            .Selector{
            {%- for path in watch_log.selectors %}
                "{{ path }}",
            {%- endfor %}
            },
            {%- if watch_log.required_tags %}
            .RequiredTags = TTagSet({ {{ watch_log.required_tags }} }),
            {%- endif %}
            {%- if watch_log.excluded_tags %}
            .ExcludedTags = TTagSet({ {{ watch_log.excluded_tags }} }),
            {%- endif %}
        },
    {%- endfor %}
    };
}

{%- if object.enable_tags %}

bool T{{ object.camel_case_name }}TypeHandler::AreTagsEnabled() const
{
    return true;
}
{%- endif %}

const NYT::NYson::TProtobufMessageType*
T{{ object.camel_case_name }}TypeHandler::GetRootProtobufType() const
{
    static const auto* type = NYT::NYson::ReflectProtobufMessageType<{{ cpp_data_model_proto_namespace }}::T{{ object.camel_case_name }}>();
    return type;
}

const TDBFields& T{{ object.camel_case_name }}TypeHandler::GetKeyFields() const
{
    return KeyFields_;
}

NYT::NOrm::NClient::NObjects::TObjectKey T{{ object.camel_case_name }}TypeHandler::GetNullKey() const
{
    return NullKey_;
}

const NYT::NOrm::NServer::NObjects::TDBTable* T{{ object.camel_case_name }}TypeHandler::GetTable() const
{
    return &{{ object.table_cpp_name }};
}

const NYT::NOrm::NServer::NObjects::TDBTable* T{{ object.camel_case_name }}TypeHandler::GetParentsTable() const
{
{%- if object.separate_parents_table %}
    return &{{ object.parents_table_cpp_name }};
{%- else %}
    return nullptr;
{%- endif %}
}

{%- if object.parent %}

NYT::NOrm::NClient::NObjects::TObjectTypeValue
T{{ object.camel_case_name }}TypeHandler::GetParentType() const
{
    {%- if not yp_compatible %}
    return static_cast<NYT::NOrm::NClient::NObjects::TObjectTypeValue>(EObjectType::{{ object.parent.camel_case_name }});
    {%- else %}
    return TObjectTypeValues::{{ object.parent.camel_case_name }};
    {%- endif %}
}

const TDBFields& T{{ object.camel_case_name }}TypeHandler::GetParentKeyFields() const
{
    return ParentKeyFields_;
}

NYT::NOrm::NServer::NObjects::TObject*
T{{ object.camel_case_name }}TypeHandler::GetParent(
    const NYT::NOrm::NServer::NObjects::TObject* object,
    std::source_location location)
{
    return object->As<T{{ object.camel_case_name }}>()
        ->{{ object.parent.camel_case_foreign_name }}().Load(location);
}
{%- endif %}

{%- if object.access_control_parent %}

NYT::NOrm::NClient::NObjects::TObjectTypeValue T{{ object.camel_case_name }}TypeHandler::GetAccessControlParentType() const
{
    {%- if not yp_compatible %}
    return static_cast<NYT::NOrm::NClient::NObjects::TObjectTypeValue>(EObjectType::{{ foreign_object_name(object.access_control_parent) }});
    {%- else %}
    return TObjectTypeValues::{{ foreign_object_name(object.access_control_parent) }};
    {%- endif %}
}

NYT::NOrm::NServer::NObjects::TObject*
T{{ object.camel_case_name }}TypeHandler::GetAccessControlParent(
    const NYT::NOrm::NServer::NObjects::TObject* object,
    std::source_location location)
{
    return object->As<T{{ object.camel_case_name }}>()
        ->{{ object.access_control_parent.cpp_camel_case_name }}().Load(location);
}

void T{{ object.camel_case_name }}TypeHandler::ScheduleAccessControlParentKeyLoad(
    const NYT::NOrm::NServer::NObjects::TObject* object)
{
    object->As<T{{ object.camel_case_name }}>()->{{ object.access_control_parent.cpp_camel_case_name }}().ScheduleLoad();
}

const TDBFields& T{{ object.camel_case_name }}TypeHandler::GetAccessControlParentKeyFields()
{
    return AccessControlParentKeyFields_;
}

{%- endif %}
{%- if object.use_custom_default_acl %}

std::vector<NYT::NOrm::NServer::NAccessControl::TAccessControlEntry>
T{{ object.camel_case_name }}TypeHandler::GetDefaultAcl()
{
    return {
{%- for ace in object.default_acl %}
        {
            .Action = NYT::NOrm::NServer::NAccessControl::EAccessControlAction::{{ ace.action | capitalize }},
{%- if ace.permissions %}
            .Permissions = {
{%- for permission in ace.permissions %}
                NYT::NOrm::NServer::NAccessControl::TAccessControlPermissionValues::{{ permission | capitalize }},
{%- endfor %}
            },
{%- endif %}
{%- if ace.attributes %}
            .Attributes = {
{%- for attribute in ace.attributes %}
                "{{ attribute }}",
{%- endfor %}
            },
{%- endif %}
        },
{%- endfor %}
    };
}
{%- endif %}

std::unique_ptr<NYT::NOrm::NServer::NObjects::TObject>
T{{ object.camel_case_name }}TypeHandler::InstantiateObject(
    const NYT::NOrm::NClient::NObjects::TObjectKey& key,
    const NYT::NOrm::NClient::NObjects::TObjectKey& parentKey,
    ISession* session)
{
{%- if not object.parent %}
    YT_VERIFY(!parentKey);
{##}
{%- endif %}
    YT_VERIFY(key.size() == {{ object.key_fields | length }});
    return std::make_unique<{{ cpp_server_plugins_namespace + "::" if object.custom_cpp_object else "" }}T{{ object.camel_case_name }}>(
    {%- for field in object.key_fields %}
        std::get<{{ field.cpp_type }}>(key[{{ loop.index0 }}]),
    {%- endfor %}
    {%- if object.parent %}
        parentKey,
    {%- endif %}
        this,
        session);
}

void T{{ object.camel_case_name }}TypeHandler::InitializeCreatedObject(
    NYT::NOrm::NServer::NObjects::TTransaction* transaction,
    NYT::NOrm::NServer::NObjects::TObject* object)
{
    TBase::InitializeCreatedObject(transaction, object);
    auto* typedObject = object->As<T{{ object.camel_case_name }}>();
    YT_VERIFY(typedObject);
    typedObject->MetaEtc().MutableLoad()->set_uuid(NYT::NOrm::NClient::NObjects::GenerateUuid());
}

void T{{ object.camel_case_name }}TypeHandler::ValidateCreatedObject(
    NYT::NOrm::NServer::NObjects::TTransaction* transaction,
    NYT::NOrm::NServer::NObjects::TObject* object)
{
    TBase::ValidateCreatedObject(transaction, object);
    auto* typedObject = object->As<T{{ object.camel_case_name }}>();
    YT_VERIFY(typedObject);
{%- for tracker in object.revision_trackers %}
    ResolveAttribute("{{ tracker.path }}", /*callback*/ {}, /*validateProtoSchemaCompliance*/ false).Attribute
        ->AsScalar()
        ->GetAttribute<NYT::NOrm::NServer::NObjects::TScalarAttribute<ui64>>(object)
        ->Store(transaction->GetStartTimestamp());
{%- endfor %}
}

void T{{ object.camel_case_name }}TypeHandler::ValidateMetaEtcOnTransactionCommit(
    NYT::NOrm::NServer::NObjects::TTransaction*,
    const T{{ object.camel_case_name }}* object)
{
    const auto& metaEtcOld = object->MetaEtc().LoadOld();
    const auto& metaEtcNew = object->MetaEtc().Load();

    // Sanity check.
    ValidateMetaUuid(metaEtcOld, metaEtcNew);

    if (metaEtcNew.name() && !this->IsObjectNameSupported()) {
        THROW_ERROR_EXCEPTION("Cannot set /meta/name for %v objects",
            NYT::NOrm::NClient::NObjects::GetGlobalObjectTypeRegistry()
                ->GetHumanReadableTypeNameOrCrash(this->GetType()));
    }
}

void T{{ object.camel_case_name }}TypeHandler::ValidateMetaEtcOnValueUpdate(
    NYT::NOrm::NServer::NObjects::TTransaction*,
    const T{{ object.camel_case_name }}* object,
    const T{{ object.camel_case_name }}::TMetaEtc& metaEtcOld,
    const T{{ object.camel_case_name }}::TMetaEtc& metaEtcNew)
{
    ValidateMetaUuid(metaEtcOld, metaEtcNew);

    {%- if superuser_only %}

    // Value updates during object creation are naturally considered as an initializers
    // and are not restricted by #UpdatableBySuperuserOnly option.
    if (object->GetState() != NYT::NOrm::NServer::NObjects::EObjectState::Creating) {
        google::protobuf::util::MessageDifferencer differencer;
        differencer.IgnoreField(T{{ object.camel_case_name }}::TMetaEtc::GetDescriptor()
            ->FindFieldByName("name"));
        differencer.IgnoreField(T{{ object.camel_case_name }}::TMetaEtc::GetDescriptor()
            ->FindFieldByName("uuid"));

        // Use #Compare instead of #Equals to honor #IgnoreField calls.
        if (!differencer.Compare(metaEtcOld, metaEtcNew)) {
            this->GetBootstrap()->GetAccessControlManager()
                ->ValidateSuperuser("change user-defined /meta attributes");
        }
    }
    {%- else %}

    // All user-defined attributes are considered updatable by any user
    // having corresponding write permission.
    Y_UNUSED(object);
    {%- endif %}
}

void T{{ object.camel_case_name }}TypeHandler::ValidateMetaUuid(
    const T{{ object.camel_case_name }}::TMetaEtc& metaEtcOld,
    const T{{ object.camel_case_name }}::TMetaEtc& metaEtcNew)
{
    // Uuid protects, for example, YP secrets from object identity theft, i.e. from ABA race conditions,
    // so we try hard to make sure uuid doesn't change.
    if (!metaEtcOld.uuid().empty() && metaEtcOld.uuid() != metaEtcNew.uuid()) {
        this->GetBootstrap()->GetAccessControlManager()->ValidateSuperuser("change /meta/uuid");
    }
}

{%- if yp_compatible %}
const TDBField* T{{ object.camel_case_name }}TypeHandler::GetAccountIdField()
{
    return &{{ object.table_cpp_name }}.Fields.MetaAccountId;
}
{%- endif %}

{%- if object.attribute_migrations %}

void T{{ object.camel_case_name }}TypeHandler::DoPrepareAttributeMigrations(
    NYT::NOrm::NServer::NObjects::TObject* object,
    const TBitSet<int>& attributeMigrations,
    const TBitSet<int>& /*forcedAttributeMigrations*/)
{
    auto* typedObject = static_cast<T{{ object.camel_case_name }}*>(object);
    {%- for attribute_migration in object.attribute_migrations %}
    if (attributeMigrations.contains(static_cast<int>(T{{ object.camel_case_name }}::EAttributeMigrations::
        {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
        {{- macros.attribute_camel_case_name(attribute_migration.target) }}))) {
        typedObject->{{ macros.attribute_accessor(attribute_migration.source) }}.ScheduleLoad();
        typedObject->{{ macros.attribute_accessor(attribute_migration.target) }}.ScheduleLoad();
        {%- if attribute_migration.custom_migrator %}
        DoPrepare
            {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
            {{- macros.attribute_camel_case_name(attribute_migration.target) }}Migration(typedObject);
        {%- endif %}
    }
    {%- endfor %}
}

void T{{ object.camel_case_name }}TypeHandler::DoFinalizeAttributeMigrations(
    NYT::NOrm::NServer::NObjects::TObject* object,
    const TBitSet<int>& /*attributeMigrations*/,
    const TBitSet<int>& forcedAttributeMigrations)
{
    auto state = object->GetState();
    if (state == NYT::NOrm::NServer::NObjects::EObjectState::Removed ||
        state == NYT::NOrm::NServer::NObjects::EObjectState::CreatedRemoved)
    {
        return;
    }

    auto* typedObject = static_cast<T{{ object.camel_case_name }}*>(object);
    {%- for attribute_migration in object.attribute_migrations %}
    {
        bool forceMigrated = forcedAttributeMigrations.contains(static_cast<int>(T{{ object.camel_case_name }}::EAttributeMigrations::
                {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                {{- macros.attribute_camel_case_name(attribute_migration.target) }}));
        bool sourceChanged = forceMigrated || typedObject->{{ macros.is_attribute_changed(attribute_migration.source) }};
        {%- if attribute_migration.on_conflict_action in ["error", "target"] or attribute_migration.reverse_write %}
        bool targetChanged = typedObject->{{ macros.is_attribute_changed(attribute_migration.target) }};
        {%- endif %}
        // On conflict action: {{ attribute_migration.on_conflict_action }}.
        {%- if attribute_migration.on_conflict_action == "error" %}
        bool newObject = state == NYT::NOrm::NServer::NObjects::EObjectState::Created;
        THROW_ERROR_EXCEPTION_IF(!newObject && sourceChanged && targetChanged,
            NYT::NOrm::NClient::EErrorCode::InvalidRequestArguments,
            "Both migration attributes are changed, migration is ambiguous "
            "(Source: {{ attribute_migration.source.full_path }}, Target: {{ attribute_migration.target.full_path }})");
        bool shouldMigrate = sourceChanged && !targetChanged;
            {%- if attribute_migration.reverse_write %}
        bool shouldWriteReverse = !sourceChanged && targetChanged;
            {%- endif %}
        {%- elif attribute_migration.on_conflict_action == "target" %}
        bool shouldMigrate = sourceChanged && !targetChanged;
            {%- if attribute_migration.reverse_write %}
        bool shouldWriteReverse = targetChanged;
            {%- endif %}
        {%- else %}
        bool shouldMigrate = sourceChanged;
            {%- if attribute_migration.reverse_write %}
        bool shouldWriteReverse = !sourceChanged && targetChanged;
            {%- endif %}
        {%- endif %}
        if (shouldMigrate) {
        {%- if attribute_migration.custom_migrator %}
            DoFinalize
                {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                {{- macros.attribute_camel_case_name(attribute_migration.target) }}Migration(typedObject);
        {%- else %}
            const auto& sourceValue = typedObject->{{ macros.attribute_accessor(attribute_migration.source) }}.Load(){{ macros.attribute_suffix(attribute_migration.source) }};
            {%- if attribute_migration.target.field.is_repeated %}
            typedObject->{{ macros.attribute_accessor(attribute_migration.target) }}.MutableLoad(){{ macros.mutable_attribute_suffix(attribute_migration.target) }}->
            {{- "assign" if not attribute_migration.target.suffix_fields else "Assign" -}}(sourceValue.begin(), sourceValue.end());
            {%- else %}
                {%- if attribute_migration.target.suffix %}
            typedObject->{{ macros.attribute_accessor(attribute_migration.target) }}.MutableLoad(){{ macros.set_attribute_suffix(attribute_migration.target, "sourceValue") }};
                {%- else %}
            (*typedObject->{{ macros.attribute_accessor(attribute_migration.target) }}.MutableLoad()) = sourceValue;
                {%- endif %}
            {%- endif %}
        {%- endif %}
        }
        {%- if attribute_migration.reverse_write %}
        if (shouldWriteReverse) {
        {%- if attribute_migration.custom_reverse_writer %}
            DoReverse
                {{- macros.attribute_camel_case_name(attribute_migration.source) }}To
                {{- macros.attribute_camel_case_name(attribute_migration.target) }}Migration(typedObject);
        {%- else %}
            const auto& targetValue = typedObject->{{ macros.attribute_accessor(attribute_migration.target) }}.Load(){{ macros.attribute_suffix(attribute_migration.target) }};
            {%- if attribute_migration.target.field.is_repeated %}
            typedObject->{{ macros.attribute_accessor(attribute_migration.source) }}.MutableLoad(){{ macros.mutable_attribute_suffix(attribute_migration.source) }}->
            {{- "assign" if not attribute_migration.source.suffix_fields else "Assign" -}}(targetValue.begin(), targetValue.end());
            {%- else %}
                {%- if attribute_migration.source.suffix %}
            typedObject->{{ macros.attribute_accessor(attribute_migration.source) }}.MutableLoad(){{ macros.set_attribute_suffix(attribute_migration.source, "targetValue") }};
                {%- else %}
            (*typedObject->{{ macros.attribute_accessor(attribute_migration.source) }}.MutableLoad()) = targetValue;
                {%- endif %}
            {%- endif %}
        {%- endif %}
        }
        {%- endif %}
    }
    {%- endfor %}
}
{%- endif %}

////////////////////////////////////////////////////////////////////////////////

std::unique_ptr<IObjectTypeHandler> Create{{ object.camel_case_name }}TypeHandler(
    IBootstrap* bootstrap,
    NYT::NOrm::NServer::NObjects::TObjectManagerConfigPtr config)
{
{%- if object.custom_type_handler %}
    return {{ cpp_server_plugins_namespace }}::Create{{ object.camel_case_name }}TypeHandler(
        bootstrap,
        std::move(config));
{%- elif object.snake_case_name == "schema" %}
    return NYT::NOrm::NServer::NObjects::CreateSchemaTypeHandler<TSchemaTypeHandler>(
        bootstrap,
        std::move(config));
{%- elif object.snake_case_name == "semaphore" %}
    return NYT::NOrm::NServer::NObjects::CreateSemaphoreTypeHandler<
        TFinalSemaphore,
        {{ cpp_data_model_proto_namespace }}::TSemaphore,
        TSemaphoreTypeHandler>(bootstrap, std::move(config));
{%- elif object.snake_case_name == "semaphore_set" %}
    return NYT::NOrm::NServer::NObjects::CreateSemaphoreSetTypeHandler<
        TFinalSemaphoreSet,
        {{ cpp_data_model_proto_namespace }}::TSemaphoreSet,
        TSemaphoreSetTypeHandler>(bootstrap, std::move(config));
{%- elif object.builtin %}
    return NYT::NOrm::NServer::NObjects::Create{{ object.camel_case_name }}TypeHandler<
        T{{ object.camel_case_name }},
        T{{ object.camel_case_name }}TypeHandler>(bootstrap, std::move(config));
{%- else %}
    return std::make_unique<T{{ object.camel_case_name }}TypeHandler>(bootstrap, std::move(config));
{%- endif %}
}

////////////////////////////////////////////////////////////////////////////////

} // namespace {{ cpp_objects_namespace }}
