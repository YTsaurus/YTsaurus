// {{ autogen_marker }}
{%- import "/macros.proto.j2" as macros %}

#include "traits.h"

#include <yt/yt/orm/client/misc/protobuf_helpers.h>
{##}
{%- if data_model_objects_proto_file %}
#include <{{ data_model_proto_path }}/{{ data_model_objects_proto_file | replace(".proto", ".pb.h") }}>
{%- else %}
#include <{{ client_schema_h }}>
{%- endif %}

#include <functional>

namespace {{ client_misc_cpp_namespace }} {

////////////////////////////////////////////////////////////////////////////////

{%-set cpp_proto_namespace = data_model_proto_package | proto_to_cpp_namespace %}

{%- for object in objects %}

{%- macro field_name(field) -%}
    {{ field.snake_case_name }}
{%- endmacro -%}

{%- macro field_getter_by_path(path) -%}
    {{ path.split("/")[1:] | join("().") }}
{%- endmacro %}

{%- macro field_size_by_path(path) -%}
    {{ field_getter_by_path(path) + "_size" }}
{%- endmacro %}

const auto TObjectTypeTraitsByType<{{ cpp_proto_namespace }}::T{{ object.camel_case_name }}>::ReferenceDescriptors = std::invoke([] {
    THashMap<NYT::NYPath::TYPath, NYT::NOrm::NClient::TReferenceDescriptor> result;
    {%- for reference in object.references %}
    {
        NYT::NOrm::NClient::TReferenceDescriptor descriptor;
        descriptor.Multiplicity = NYT::NOrm::NClient::EReferenceMultiplicity::{{ reference.kind }};
        descriptor.Option.set_foreign_type("{{ reference.foreign_type }}");
        descriptor.Option.set_foreign_backref_path("{{ reference.foreign_backref_path }}");
        descriptor.Option.set_foreign_backref_number({{ reference.foreign_backref_number }});
        {%- if reference.key_storage_kind == "Columnar" %}
            {%- for path in reference.key_storage_paths %}
        descriptor.Option.mutable_columnar_key_storage()->add_paths("{{ path }}");
            {%- endfor %}
        {%- elif reference.key_storage_kind == "Proto" %}
        descriptor.Option.mutable_proto_key_storage()->set_path("{{ reference.proto_key_storage_path }}");
            {%- for suffix in reference.proto_key_storage_suffixes %}
        descriptor.Option.mutable_proto_key_storage()->add_suffixes("{{ suffix }}");
            {%- endfor %}
        {%- else %}
            {%- if not reference.table_suffix and not reference.override_prefix %}
        descriptor.Option.mutable_tabular_key_storage();
            {%- else %}
                {%- if reference.table_suffix %}
        descriptor.Option.mutable_tabular_key_storage()->set_table_suffix("{{ reference.table_suffix }}");
                {%- endif %}
                {%- if reference.override_prefix %}
        descriptor.Option.mutable_tabular_key_storage()->set_override_prefix("{{ reference.override_prefix }}");
                {%- endif %}
            {%- endif %}
        {%- endif %}
        {%- if reference.store_parent_key %}
        descriptor.Option.set_store_parent_key({{ reference.store_parent_key | to_cpp_bool }});
        {%- endif %}
        {%- if reference.allow_non_empty_removal %}
        descriptor.Option.set_allow_non_empty_removal({{ reference.allow_non_empty_removal | to_cpp_bool }});
        {%- endif %}
        {%- if reference.generate_view %}
        descriptor.Option.mutable_view()->set_path("{{ reference.view_path }}");
        descriptor.Option.mutable_view()->set_number({{ reference.view_number }});
        {%- endif %}
        result["{{ reference.field.path }}"] = std::move(descriptor);
    }
    {%- endfor %}
    return result;
});

bool ExtractObjectMetaKeyFields(const {{ object.meta | message_cpp_full_name }}& source, {{ object.meta | message_cpp_full_name }}& destination)
{
    bool hasAllKeys = true;

    {%- for field in object.key_fields %}
    {%- if field.is_optional(proto3) %}
    if (source.has_{{ field_name(field) }}()) {
        destination.set_{{ field_name(field) }}(source.{{ field_name(field) }}());
    } else {
        hasAllKeys = false;
    }
    {%- else %}
    destination.set_{{ field_name(field) }}(source.{{ field_name(field) }}());
    {%- endif %}
    {%- endfor %}

    {%- if object.parent %}
    {%- for field in object.meta_parent_key_fields %}
    {%- if field.is_optional(proto3) %}
    if (source.has_{{ field_name(field) }}()) {
        destination.set_{{ field_name(field) }}(source.{{ field_name(field) }}());
    } else {
        hasAllKeys = false;
    }
    {%- else %}
    destination.set_{{ field_name(field) }}(source.{{ field_name(field) }}());
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    return hasAllKeys;
}

NYT::NOrm::NClient::NObjects::TObjectKey GetObjectKey(
    const {{ object.meta | message_cpp_full_name }}& source,
    bool ensureAllKeysPresent)
{
    {%- set optional_primary_key_fields = object.primary_key | selectattr("is_optional", "yields", True, proto3=proto3) | list %}
    {%- if optional_primary_key_fields | length > 0 %}
    bool hasAllKeys =
    {%- for field in optional_primary_key_fields %}
        source.has_{{ field_name(field) }}(){% if not loop.last %} &&{% endif %}
    {%- endfor -%};
    THROW_ERROR_EXCEPTION_IF(ensureAllKeysPresent && !hasAllKeys,
        "Missing keys for %v",
        source.GetTypeName());
    {%- else %}
    Y_UNUSED(ensureAllKeysPresent);
    {%- endif %}

    return NYT::NOrm::NClient::NObjects::TObjectKey(
        {%- for field in object.primary_key %}
        source.{{ field.snake_case_name }}(){% if not loop.last %},{% endif %}
        {%- endfor %});
}

void SetObjectKey(
    {{ object.meta | message_cpp_full_name }}& destination,
    const NYT::NOrm::NClient::NObjects::TObjectKey& key)
{
    THROW_ERROR_EXCEPTION_IF(0u != key.size() && key.size() != {{ object.primary_key|length }},
        "Missing keys for %v",
        destination.GetTypeName());
    {%- for field in object.primary_key %}
    destination.set_{{ field.snake_case_name }}(key.GetWithDefault<std::decay_t<decltype(destination.{{ field.snake_case_name }}())>>({{ loop.index0 }}));
    {%- endfor %}
}

{%- if object.parent %}
NYT::NOrm::NClient::NObjects::TObjectKey GetParentKey(
    const {{ object.meta | message_cpp_full_name }}& source,
    bool ensureAllKeysPresent)
{
    {%- set parent_primary_key_fields = object.meta_parent_primary_key_fields %}
    {%- set optional_parent_primary_key_fields = parent_primary_key_fields | selectattr("is_optional", "yields", True, proto3=proto3) | list %}
    {%- if optional_parent_primary_key_fields | length > 0 %}
    bool hasAllKeys =
    {%- for field in optional_parent_primary_key_fields %}
        source.has_{{ field_name(field) }}(){% if not loop.last %} &&{% endif %}
    {%- endfor -%};
    THROW_ERROR_EXCEPTION_IF(ensureAllKeysPresent && !hasAllKeys,
        "Missing parent keys for %v",
        source.GetTypeName());
    {%- else %}
    Y_UNUSED(ensureAllKeysPresent);
    {%- endif %}
    return NYT::NOrm::NClient::NObjects::TObjectKey(
    {%- for field in parent_primary_key_fields %}
        source.{{ field_name(field) }}(){% if not loop.last %},{% endif %}
    {%- endfor -%});
}
{%- endif %}

void TrySetParentKey(
    [[ maybe_unused ]] {{ object.meta | message_cpp_full_name }}& destination,
    [[ maybe_unused ]] const NYT::NOrm::NClient::NObjects::TObjectKey& key)
{
    {%- if object.parent %}
    THROW_ERROR_EXCEPTION_IF(0u != key.size() && key.size() != {{ object.parent.primary_key|length }},
        "Missing keys for %v",
        destination.GetTypeName());
    {%- for field in object.meta_parent_primary_key_fields %}
    destination.set_{{ field_name(field) }}(key.GetWithDefault<std::decay_t<decltype(destination.{{ field_name(field) }}())>>({{ loop.index0 }}));
    {%- endfor %}
    {%- endif %}
}

NYT::NOrm::NClient::NObjects::TObjectKey GetPrimaryKey(
    const {{ object.meta | message_cpp_full_name }}& source,
    bool ensureAllKeysPresent)
{
    return {% if object.parent -%} GetParentKey(source, ensureAllKeysPresent) + {% endif %}GetObjectKey(source, ensureAllKeysPresent);
}

void SetPrimaryKey(
    {{ object.meta | message_cpp_full_name }}& destination,
    const NYT::NOrm::NClient::NObjects::TObjectKey& key)
{
    {%- set parent_key_length = object.parent.primary_key|length if object.parent else 0 %}
    THROW_ERROR_EXCEPTION_IF(key.size() != {{ parent_key_length + object.primary_key|length }},
        "Missing keys for %v",
        destination.GetTypeName());

    {%- if object.parent %}
    {%- for field in object.meta_parent_primary_key_fields %}
    destination.set_{{ field_name(field) }}(key.GetWithDefault<std::decay_t<decltype(destination.{{ field_name(field) }}())>>({{ loop.index0 }}));
    {%- endfor %}
    {%- endif %}

    {%- for field in object.primary_key %}
    destination.set_{{ field_name(field) }}(key.GetWithDefault<std::decay_t<decltype(destination.{{ field_name(field) }}())>>({{ loop.index0 + parent_key_length }}));
    {%- endfor %}
}

{%- macro _get_deprecated_references(path, field) %}
    {%- if field.is_repeated -%}
    std::vector<NYT::NOrm::NClient::NObjects::TObjectKey> keys;
    keys.reserve(source.{{ field_size_by_path(path) }}());
    for (const auto& value : source.{{ field_getter_by_path(path) }}()) {
        {{ cpp_proto_namespace }}::T{{ field.foreign_object_type }} referencedObject;
        referencedObject.mutable_meta()->set_{{ field.reference_deprecated.foreign_object.primary_key[0].snake_case_name }}(value);
        auto objectKey = GetObjectKey(referencedObject.meta());
        if (objectKey.HasNonZeroKeyField()) {
            keys.push_back(std::move(objectKey));
        }
    }
    if (!keys.empty()) {
        result[std::pair{EObjectType::{{ field.foreign_object_type }}, "{{ path }}"}] = std::move(keys);
    }
    {%- else -%}
    {{ cpp_proto_namespace }}::T{{ field.foreign_object_type }} referencedObject;
    referencedObject.mutable_meta()->set_{{ field.reference_deprecated.foreign_object.primary_key[0].snake_case_name }}(source.{{ field_getter_by_path(path) }}());
    auto objectKey = GetObjectKey(referencedObject.meta());
    if (objectKey.HasNonZeroKeyField()) {
        result[std::pair{EObjectType::{{ field.foreign_object_type }}, "{{ path }}"}] = {std::move(objectKey)};
    }
    {%- endif %}
{%- endmacro %}

{%- macro _get_columnar_multi_references(reference) -%}
    std::vector<{{ reference.foreign_object.meta | message_cpp_full_name }}> metas;
    {%- for path in reference.key_storage_paths %}
    {
        auto vals = NYT::NOrm::NClient::VectorFromProtoField(source.{{ field_getter_by_path(path) }}());
        {%- if loop.index0 == 0 %}
        metas.resize(vals.size());
        {%- endif %}
        for (int i = 0; i < std::ssize(vals); ++i) {
            metas[i].set_{{ reference.foreign_object.primary_key[loop.index0].snake_case_name }}(vals[i]);
        }
    }
    {%- endfor %}
    std::vector<NYT::NOrm::NClient::NObjects::TObjectKey> keys;
    keys.reserve(metas.size());
    for (const auto& meta : metas) {
        auto objectKey = GetObjectKey(meta);
        if (objectKey.HasNonZeroKeyField()) {
            keys.push_back(std::move(objectKey));
        }
    }
{%- endmacro %}

{%- macro _get_proto_multi_references(reference) -%}
    std::vector<NYT::NOrm::NClient::NObjects::TObjectKey> keys;
    {
        std::vector<NYT::NOrm::NClient::NObjects::TObjectKey> keyStorageKeys;
        auto vals = NYT::NOrm::NClient::VectorFromProtoField(source.{{ field_getter_by_path(reference.proto_key_storage_path) }}());
        keyStorageKeys.reserve(vals.size());
        for (const auto& value : vals) {
            {{ reference.foreign_object.meta | message_cpp_full_name }} meta;
        {%- if reference.proto_key_storage_suffixes %}
            {%- for suffix in reference.proto_key_storage_suffixes -%}
            {%- set suffix = suffix[1:] %}
            meta.set_{{ reference.foreign_object.primary_key[loop.index0].snake_case_name }}(value.{{ suffix }}());
            {%- endfor %}
        {%- else %}
            meta.set_{{ reference.foreign_object.primary_key[0].snake_case_name }}(value);
        {%- endif %}
            auto objectKey = GetObjectKey(meta);
            if (objectKey.HasNonZeroKeyField()) {
                keyStorageKeys.push_back(std::move(objectKey));
            }
        }
        keys.reserve(keys.size() + keyStorageKeys.size());
        std::ranges::move(keyStorageKeys, std::back_inserter(keys));
    }
{%- endmacro %}

{%- macro _get_columnar_singular_references(reference) -%}
    {{ reference.foreign_object.meta | message_cpp_full_name }} meta;
    {%- for path in reference.key_storage_paths %}
    {
        meta.set_{{ reference.foreign_object.primary_key[loop.index0].snake_case_name }}(source.{{ field_getter_by_path(path) }}());
    }
    {%- endfor %}
{%- endmacro %}

{%- macro _get_proto_singular_references(reference) -%}
    {{ reference.foreign_object.meta | message_cpp_full_name }} meta;
    {%- if reference.proto_key_storage_suffixes %}
    auto value = source.{{ field_getter_by_path(reference.proto_key_storage_path) }}();
        {%- for suffix in reference.proto_key_storage_suffixes -%}
            {%- set suffix = suffix[1:] %}
    meta.set_{{ reference.foreign_object.primary_key[loop.index0].snake_case_name }}(value.{{ suffix }}());
        {%- endfor %}
    {%- else %}
        {%- set path = reference.proto_key_storage_path %}
    meta.set_{{ reference.foreign_object.primary_key[0].snake_case_name }}(source.{{ field_getter_by_path(path) }}());
    {%- endif %}
{%- endmacro %}


THashMap<std::pair<EObjectType, NYT::NYPath::TYPath>, std::vector<NYT::NOrm::NClient::NObjects::TObjectKey>> GetReferences(
    [[maybe_unused]] const {{ cpp_proto_namespace }}::T{{ object.camel_case_name }}& source)
{
    THashMap<std::pair<EObjectType, NYT::NYPath::TYPath>, std::vector<NYT::NOrm::NClient::NObjects::TObjectKey>> result;
    {%- for path, field in object.references_deprecated.items() %}
    {
        {{ _get_deprecated_references(path, field) | indent(4) }}
    }
    {%- endfor %}
    {%- for reference in object.references if reference.key_storage_kind != "Tabular" %}
    {
        {%- if reference.field.is_repeated %}
            {%- if reference.key_storage_kind == "Columnar" %}
        {{ _get_columnar_multi_references(reference) | indent(4) }}
            {%- else %}
        {{ _get_proto_multi_references(reference) | indent(4) }}
            {%- endif %}
        if (!keys.empty()) {
            result[std::pair{EObjectType::{{ reference.foreign_object.camel_case_name }}, "{{ reference.field.path }}"}] = std::move(keys);
        }
        {%- else %}
            {%- if reference.key_storage_kind == "Columnar" %}
        {{ _get_columnar_singular_references(reference) | indent(4) }}
            {%- else %}
        {{ _get_proto_singular_references(reference) | indent(4) }}
            {%- endif %}
        auto objectKey = GetObjectKey(meta);
        if (objectKey.HasNonZeroKeyField()) {
            result[std::pair{EObjectType::{{ reference.foreign_object.camel_case_name }}, "{{ reference.field.path }}"}] = {std::move(objectKey)};
        }
        {%- endif %}
    }
    {%- endfor %}
    return result;
}

////////////////////////////////////////////////////////////////////////////////
{%- endfor %}
{{ macros.line_break() }}
} // namespace {{ client_misc_cpp_namespace }}
