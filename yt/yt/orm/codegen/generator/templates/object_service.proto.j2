// {{ autogen_marker }}
package {{ client_proto_package }};
{% if access_control_file %}
import "{{ data_model_proto_path }}/{{ access_control_file }}";
{%- endif %}
import "{{ client_schema_proto }}";

import "yt_proto/yt/orm/client/proto/object.proto";

import "yt_proto/yt/client/api/rpc_proxy/proto/api_service.proto";

import "yt_proto/yt/core/yson/proto/protobuf_interop.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

{% if yp_compatible -%}
option java_package = "{{ client_java_package }}";
option java_outer_classname = "Object";
{%- endif -%}
{%- if client_go_api_package %}
option go_package = "{{ client_go_api_package }}";
{%- endif %}

////////////////////////////////////////////////////////////////////////////////

enum EEventType
{
    ET_OBJECT_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ET_OBJECT_CREATED = 1
    [(NYT.NYson.NProto.enum_value_name) = "object_created"];

    ET_OBJECT_REMOVED = 2
    [(NYT.NYson.NProto.enum_value_name) = "object_removed"];

    ET_OBJECT_UPDATED = 3
    [(NYT.NYson.NProto.enum_value_name) = "object_updated"];
}

message TTransactionContext
{
    map<string, string> items = 1 [(NYT.NYson.NProto.yson_map) = true];
}

message TEvent
{
    // The timestamp of the event.
    optional uint64 timestamp = 1;

    // Useful for history events lookups.
    optional google.protobuf.Timestamp history_time = 7;

    // Same as |history_time|. Only one of them can be present based on |history_time_mode| db option.
    optional uint64 history_timestamp = 8;

    // Event type.
    optional EEventType event_type = 2;

    // Object id (serialized object key, actually).
    // Deprecated, switch to using meta in a format of your choice.
    optional string object_id = 3 [deprecated = true];
    // Metadata of the object, if requested.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 4;

    // Transaction context (see TReqStartTransaction).
    optional TTransactionContext transaction_context = 5;

    // Each character of the summary corresponds to one attribute.
    // Values: 'u' (unknown), 't' (true), 'f' (false).
    // True means the attribute was definitely affected.
    // False means it was definitely not affected.
    // Unknown means there is no information either way.
    optional string changed_attributes_summary = 6;

    message TIndex
    {
        optional int64 tablet = 1;
        optional int64 row = 2;
        optional int64 event = 3;
    }

    optional TIndex index = 9;

    repeated int32 changed_tags = 10;
}

////////////////////////////////////////////////////////////////////////////////

message TCommonRequestOptions
{
    // If true then method call returns performance statistics.
    optional bool fetch_performance_statistics = 1;

    // Overrides default ORM option and allows underlying storage to perform full scan.
    optional bool allow_full_scan = 2;
}

message TPerformanceStatistics
{
    // Number of DB read phases during the execution.
    // Each phase consists of a number of read requests executed simultaneously.
    optional int64 read_phase_count = 1;

    message TSelectQueryStatistics
    {
        optional string table_name = 1;
        repeated NYT.NApi.NRpcProxy.NProto.TQueryStatistics statistics = 2;
    }

    repeated TSelectQueryStatistics select_query_statistics = 2;
}

message TMutatingTransactionOptions
{
    // Arbitrary context, which is written to watch logs and history.
    // Useful for storing committer properties, e.g.: User-Agent header, IP address, user login.
    // The commit transaction context, if given, merges with the start transaction context.
    // In case of the same keys the commit transaction context overwrites the start transaction context.
    optional TTransactionContext transaction_context = 1;

    optional bool skip_watch_log = 2;
    optional bool skip_history = 3;
    optional bool skip_revision_bump = 4;
    optional bool allow_removal_with_non_empty_reference = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TAttributeSelector
{
    // YPaths of requested attributes.
    repeated string paths = 1;
}

message TAttributeList
{
    // COMPAT(babenko): deprecated; use value_payloads instead.
    // Values are in YSON; nulls are encoded as empty strings.
    // Value order coincides with that of TAttributeSelector.paths.
    repeated bytes values = 1 [(NYT.NYson.NProto.yson_string) = true];

    // Contains single element if TGetObjectOptions.fetch_root_object is true.
    // Otherwise contains one element per every TAttributeSelector.path in the same order if fetch_values is true.
    // Otherwise contains no element.
    repeated NYT.NOrm.NClient.NProto.TPayload value_payloads = 2;

    // Timestamp order coincides with that of TAttributeSelector.paths.
    // Empty if TGetObjectOptions.fetch_timestamps is false.
    repeated uint64 timestamps = 3;
}

message TObjectFilter
{
    // Textual query string (ORM dialect).
    optional string query = 1;
}

message TSelectLimit
{
    // Maximum number of results to fetch.
    optional int64 value = 1;
}

message TSelectOffset
{
    // Number of leading results to skip.
    optional int64 value = 1;
}

message TSetUpdate
{
    // YPath pointing to the attribute to set.
    optional string path = 1;

    // COMPAT(babenko): deprecated; use value_payload instead.
    // Attribute value; in YSON.
    optional bytes value = 2 [(NYT.NYson.NProto.yson_string) = true];

    // Attribute value.
    optional NYT.NOrm.NClient.NProto.TPayload value_payload = 4;

    // If true then missing intermediate nodes along the #path do not cause an error.
    optional bool recursive = 3;

    // If true apply update with shared write lock.
    optional bool shared_write = 5;

    // Update mode for aggregate column.
    optional NYT.NOrm.NClient.NProto.EAggregateMode aggregate_mode = 6;
}

message TSetRootUpdate
{
    // List of YPath pointing to the attributes to set.
    repeated string paths = 1;

    // Attribute value.
    optional NYT.NOrm.NClient.NProto.TPayload value_payload = 2;

    // If true then missing intermediate nodes along the #path do not cause an error.
    optional bool recursive = 3;

    // If true apply updates with shared write lock.
    optional bool shared_write = 4;

    // Update mode for aggregate column.
    optional NYT.NOrm.NClient.NProto.EAggregateMode aggregate_mode = 5;
}

message TRemoveUpdate
{
    // YPath pointing to the attribute to remove.
    optional string path = 1;

    // If true then missing intermediate nodes along the #path do not cause an error.
    optional bool force = 2;

    reserved "shared_write", "aggregate_mode";
    reserved 3, 4;
}

message TLockUpdate
{
    // YPath pointing to the attribute to lock.
    optional string path = 1;

    // Lock type to use.
    optional NYT.NOrm.NClient.NProto.ELockType lock_type = 2;
}

message TMethodCall
{
    optional string path = 1;
    optional NYT.NOrm.NClient.NProto.TPayload value_payload = 2;
}

message TAttributeTimestampPrerequisite
{
    // YPath pointing to the attribute to check.
    optional string path = 1;

    // For the prerequisite to succeed, the actual timestamp must not exceed this one.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGenerateTimestamp
{ }

message TRspGenerateTimestamp
{
    // A new (unique) timestamp.
    optional uint64 timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqStartTransaction
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 start_timestamp = 1;

    // If missing, master will start and manage its own underlying transaction.
    // Otherwise specifies id of an underlying transaction started via some RPC proxy,
    // which can be collocated with master.
    // Master will not own such transaction: in particular, upon CommitTransaction
    // request master will just flush modifications into the transaction and will not commit the transaction,
    // so the separate CommitTransaction request must be sent to the underlying transaction owner.
    // Useful for atomically applying changes to ORM and other underlying tables.
    optional string underlying_transaction_id = 2;

    // Network address of an underlying transaction owner.
    // ORM master attaches to the transaction by the given address.
    // If missing, master will try to attach to the collocated RPC proxy.
    optional string underlying_transaction_address = 3;

    // Common request options.
    optional TCommonRequestOptions common_options = 4;

    reserved "transaction_context";
    reserved 5;

    optional TMutatingTransactionOptions mutating_transaction_options = 6;
}

message TRspStartTransaction
{
    // Transaction id.
    optional string transaction_id = 1;

    // Start timestamp of the transaction.
    optional uint64 start_timestamp = 2;

    // Start time of the transaction.
    // Useful for indexing history by time (see |commit_time| history table option).
    optional google.protobuf.Timestamp start_time = 3;
}

////////////////////////////////////////////////////////////////////////////////

// NB! Underlying transaction will be committed only if it is owned by the master
//     (TReqStartTransaction.underlying_transaction_id was empty).
message TReqCommitTransaction
{
    // Transaction id.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    // Transaction context (see TMutatingTransactionOptions).
    optional TTransactionContext transaction_context = 2;

    // Common request options.
    optional TCommonRequestOptions common_options = 3;
}

message TRspCommitTransaction
{
    // Commit timestamp of the transaction.
    // Zero if the underlying transaction was not committed.
    optional uint64 commit_timestamp = 1;

    // Start time of the commit.
    // Useful for indexing history by time (see history_commit_time DB option).
    optional google.protobuf.Timestamp start_time = 2;

    // Timestamp of the start of the commit. Provided only if
    // `commit_time` option is in HCT_TRANSACTION_COMMIT_START mode for the history table.
    optional fixed64 commit_start_timestamp = 6;

    // End time of the commit.
    optional google.protobuf.Timestamp finish_time = 3;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 4;

    // Lightweight performance statistics for the whole transaction.
    optional TPerformanceStatistics total_performance_statistics = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TReqAbortTransaction
{
    // Transaction id.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;
}

message TRspAbortTransaction
{ }

////////////////////////////////////////////////////////////////////////////////

// Parameters for updating an existing object in the context of a |Create| request ("upsert").
// Contents are similar to the corresponding fields in |Update|.
// A message with empty contents simply prevents an exception in |Create|.
message TUpdateIfExisting
{
    // Update these paths in the existing object.
    // Values are taken from the corresponding paths in |attributes|, unless supplied directly in
    // |set_updates| (for the case of setting a different value when creating vs. updating).
    repeated TSetUpdate set_updates = 1;

    // Same as |set_updates|, except |value_payload|, if present for the case of different values
    // when creating vs. updating, is a partially-filled tree with the same root as |attributes|,
    // instead of individual values. If a path is missing from |value_payload|, it will be picked
    // up from |attributes|.
    repeated TSetRootUpdate set_root_updates = 4;

    // Remove these paths in the existing object.
    repeated TRemoveUpdate remove_updates = 2;

    // Lock these paths in the existing object.
    repeated TLockUpdate lock_updates = 3;

    repeated TMethodCall method_calls = 6;

    // Prerequisites to check.
    repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 5;
}

message TReqCreateObject
{
    // Transaction id.
    // If missing, just creates the object w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    // Type of the object to create.
    optional {{ data_model_proto_package }}.EObjectType object_type = 2;

    // COMPAT(babenko): deprecated; use attributes_payload instead.
    // Object attributes; in YSON.
    optional bytes attributes = 3 [(NYT.NYson.NProto.yson_string) = true];

    // Object attributes.
    optional NYT.NOrm.NClient.NProto.TPayload attributes_payload = 4;

    // Format to use in response. None will respond with object_id and fqid. Yson or proto will
    // leave these empty and fill meta with /meta of the newly created object.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 5;

    // If a matching object already exists (key fields must be supplied in attributes),
    // update the existing object instead of failing.
    optional TUpdateIfExisting update_if_existing = 6;

    // Common request options.
    optional TCommonRequestOptions common_options = 7;
}

message TRspCreateObject
{
    // Object id (filled if requested format is NONE and the object has a single string key).
    // Deprecated, switch to using meta in a format of your choice.
    optional string object_id = 1 [deprecated = true];

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;

    // Fqid of the newly created object (filled if requested format is NONE).
    // Deprecated, switch to using meta in a format of your choice.
    optional string fqid = 3 [deprecated = true];

    // Metadata of the newly created object, if requested instead of separate fields.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 4;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 5;

    optional TAttributeList method_results = 6;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCreateObjects
{
    // Transaction id.
    // If missing, just creates the objects w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to create.
        optional {{ data_model_proto_package }}.EObjectType object_type = 1;

        // COMPAT(babenko): deprecated; use attributes_payload instead.
        // Object attributes; in YSON.
        optional bytes attributes = 2 [(NYT.NYson.NProto.yson_string) = true];

        // Object attributes.
        optional NYT.NOrm.NClient.NProto.TPayload attributes_payload = 3;

        // If a matching object already exists (key fields must be supplied in attributes),
        // update the existing object instead of failing.
        optional TUpdateIfExisting update_if_existing = 4;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;

    // Format to use in response. None will respond with object_id and fqid. Yson or proto will
    // leave these empty and fill meta with /meta of the newly created object.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 3;

    // Common request options.
    optional TCommonRequestOptions common_options = 4;
}

// Objects are created concurrently for better performance, so side-effects of different creations can be interleaved.
//
// E.g. creation request [parent, child1, child2] can successfully be executed in order [parent, child1, child2],
// but may as well fail due to different order of execution [child2, child1, parent] with "Parent does not exist" error.
//
// It is recommended to separate creation requests inside one transaction by object types.
message TRspCreateObjects
{
    message TSubresponse
    {
        // Object id (filled if requested format is NONE and the object has a single string key).
        // Deprecated, switch to using meta in a format of your choice.
        optional string object_id = 1 [deprecated = true];

        // Fqid of the newly created object (filled if requested format is NONE).
        // Deprecated, switch to using meta in a format of your choice.
        optional string fqid = 3 [deprecated = true];

        // Metadata of the newly created object, if requested instead of separate fields.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 4;

        optional TAttributeList method_results = 5;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TReqRemoveObject
{
    // Transaction id.
    // If missing, just removes the object w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    // Use exactly one of the two following fields.
    // Id of the object to remove, if the type has a single string id field.
    optional string object_id = 2 [deprecated = true];
    // A subset of the object's /meta identifying the object to remove.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 4;

    // Type of the object to remove.
    optional {{ data_model_proto_package }}.EObjectType object_type = 3;

    // If false, fails with an error on nonexistent object.
    // If true, ignores nonexistent object.
    optional bool ignore_nonexistent = 5;

    // Common request options.
    optional TCommonRequestOptions common_options = 6;

    // Overrides default references option (see forbid_non_empty_removal reference option and global option).
    // NB: This option is applied for the whole transaction.
    optional bool allow_removal_with_non_empty_reference = 7;
}

message TRspRemoveObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 2;

    // If object has finalizers, it cannot be removed completely, but only transition to |finalized| state.
    // It means that object becomes read-only
    // until all controllers garbage-collect this object and remove their finalizers
    // after which the object would be removed.
    //
    // If this field is non-empty, then object is in |finalized| state and awaits for its finalizers.
    optional uint64 finalization_start_time = 3;
}

////////////////////////////////////////////////////////////////////////////////

// Objects are removed concurrently for better performance, so side-effects of different removals can be interleaved.
//
// For example, in the hierarchy of TService -> TPodSet -> TPod
// removal of [pod set, service, pod] can be executed in order [remove pod, remove pod set, remove service] or
// alternatively can fail due to attempt to remove pod twice:
//     [remove pod as a child of pod set during pod set removal,
//      remove pod as a third input argument,
//      ...].
// Also duplicate object`s identifiers in request can cause fail too due to attempt to remove object twice.
message TReqRemoveObjects
{
    // Transaction id.
    // If missing, just removes the objects w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to remove.
        optional {{ data_model_proto_package }}.EObjectType object_type = 1;

        // Use exactly one of the two following fields.
        // Id of the object to remove, if the type has a single string id field.
        optional string object_id = 2 [deprecated = true];
        // A subset of the object's /meta identifying the object to remove.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 3;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;

    // If false, fails with an error on nonexistent object(s).
    // If true, ignores nonexistent object(s).
    optional bool ignore_nonexistent = 3;

    // Common request options.
    optional TCommonRequestOptions common_options = 4;

    // Overrides default references option (see |forbid_non_empty_removal| reference option and global option).
    // NB: This option is applied for the whole transaction.
    optional bool allow_removal_with_non_empty_reference = 5;
}

message TRspRemoveObjects
{
    message TSubresponse
    {
        // See TRspRemoveObject.finalization_start_time.
        optional uint64 finalization_start_time = 1;
    }

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 2;

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 3;
}

////////////////////////////////////////////////////////////////////////////////

// Note that some update handlers (in particular, validators) are postponed until the transaction commit.
message TReqUpdateObject
{
    // Transaction id.
    // If missing, just updates the object w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    // Use exactly one of the two following fields.
    // Id of the object to update, if the type has a single string id field.
    optional string object_id = 2 [deprecated = true];
    // A subset of the object's /meta identifying the object to update.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 8;

    // Type of the object to update.
    optional {{ data_model_proto_package }}.EObjectType object_type = 5;

    // Describes set-like updates.
    repeated TSetUpdate set_updates = 3;

    // Describes set-like updates with root corresponding to the object type.
    repeated TSetRootUpdate set_root_updates = 9;

    // Describes remove-like updates.
    repeated TRemoveUpdate remove_updates = 4;

    // Describes lock-like updates.
    repeated TLockUpdate lock_updates = 10;

    repeated TMethodCall method_calls = 13;

    // Prerequisites to check.
    repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 6;

    reserved 7;
    reserved "create_nonexistent";

    // If false, fails with an error on nonexistent object.
    // If true, ignores nonexistent object.
    optional bool ignore_nonexistent = 12;

    // Common request options.
    optional TCommonRequestOptions common_options = 11;

    // Methods response format.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 14;
}

message TRspUpdateObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 2;

    optional TAttributeList method_results = 3;
}

////////////////////////////////////////////////////////////////////////////////

// Note that the execution order of the individual subrequests is not guaranteed, and so
// it is recommended to use the method with independent (in terms of side-effects too) subrequests.
// In particular, subrequest finalizers can be postponed till the end of the request
// for the sake of effectiveness (one preload instead of many) or model requirements (to allow
// invalid intermediate states).
message TReqUpdateObjects
{
    // Transaction id.
    // If missing, just updates the objects w/o any transaction.
    // The request must be sent to the master owning the transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to update.
        optional {{ data_model_proto_package }}.EObjectType object_type = 1;

        // Use exactly one of the two following fields.
        // Id of the object to update, if the type has a single string id field.
        optional string object_id = 2 [deprecated = true];
        // A subset of the object's /meta identifying the object to update.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 6;

        // Describes set-like updates.
        repeated TSetUpdate set_updates = 3;

        // Describes set-like updates with root corresponding to the object type.
        repeated TSetRootUpdate set_root_updates = 7;

        // Describes remove-like updates.
        repeated TRemoveUpdate remove_updates = 4;

        // Describes lock-like updates.
        repeated TLockUpdate lock_updates = 8;

        repeated TMethodCall method_calls = 9;

        // Prerequisites to check.
        repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 5;
   }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;

    reserved 4;
    reserved "create_nonexistent";

    // If false, fails with an error on nonexistent object.
    // If true, ignores nonexistent object.
    optional bool ignore_nonexistent = 5;

    // Common request options.
    optional TCommonRequestOptions common_options = 3;

    // Methods response format.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 6;
}

message TRspUpdateObjects
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 2;

    message Subresponse
    {
        optional TAttributeList method_results = 1;
    }

    repeated Subresponse subresponses = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TGetObjectOptions
{
    // If false, GetObject(s) fails with an error on nonexistent object(s).
    // If true, silently returns null TAttributeList for nonexistent objects.
    optional bool ignore_nonexistent = 1;
    // If true, silently excludes nonexistent objects, the order of existent objects is preserved.
    optional bool skip_nonexistent = 5;

    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 2 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 3;

    // If true then all requested attributes will be merged into
    // root object corresponding to the object type.
    optional bool fetch_root_object = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObject
{
    // Only one of the three following options should be specified.

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 9;

    // Transaction id to specify the transaction to read from.
    // Allows to read uncommitted changes.
    optional string transaction_id = 10;

    // Use exactly one of the two following fields.
    // Id of the object to get, if the type has a single string id field.
    optional string object_id = 2 [deprecated = true];
    // A subset of the object's /meta identifying the object to get.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 7;

    // Type of the object to get.
    optional {{ data_model_proto_package }}.EObjectType object_type = 4;

    // Describes which attributes are to fetched.
    // TRspGetObject.result.attributes will contain exactly this number of attributes.
    optional TAttributeSelector selector = 3;

    // Format to use in response.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 5;

    // Specific request options.
    optional TGetObjectOptions options = 6;

    // Common request options.
    optional TCommonRequestOptions common_options = 8;
}

message TRspGetObject
{
    // The requested attributes.
    optional TAttributeList result = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObject.timestamp.
    optional uint64 timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjects
{
    // Only one of the three following options should be specified.

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 7;

    // Transaction id to specify the transaction to read from.
    // Allows to read uncommitted changes.
    optional string transaction_id = 9;

    // Type of objects to get.
    optional {{ data_model_proto_package }}.EObjectType object_type = 2;

    message TSubrequest
    {
        // Use exactly one of the two following fields.
        // Id of the object to get, if the type has a single string id field.
        optional string object_id = 1 [deprecated = true];
        // A subset of the object's /meta identifying the object to get.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 2;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 3;

    // Describes which attributes to fetch.
    // TRspGetObjects.results.attributes will contain exactly this number of attributes.
    optional TAttributeSelector selector = 4;

    // Format to use in response.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 5;

    // Request options.
    optional TGetObjectOptions options = 6;

    // Common request options.
    optional TCommonRequestOptions common_options = 8;
}

message TRspGetObjects
{
    message TSubresponse
    {
        // The requested attributes.
        optional TAttributeList result = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObjects.timestamp.
    optional uint64 timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TSelectObjectsOptions
{
    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 1 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 2;

    // Number of leading results to skip.
    optional int32 offset = 3;

    // Maximum number of results to fetch.
    optional int32 limit = 4;

    // Continuation token indicates the next record to be fetched. Opaque for the client.
    optional string continuation_token = 5;

    // If true then all requested attributes will be merged into
    // root object corresponding to the object type.
    optional bool fetch_root_object = 6;

    // If true then response will contain matching finalizing objects. Otherwise, they are filtered out.
    // If not specified, Config's |fetch_finalizing_objects_by_default| is used.
    optional bool fetch_finalizing_objects = 9;

    // If true, exisiting results will be returned when the time runs out.
    // The time when the return of results begins is regulated by |partial_result_request_timeout_slack|.
    optional bool enable_partial_result = 10;

    reserved 7, 8;
}

////////////////////////////////////////////////////////////////////////////////

message TObjectOrderByExpression
{
    optional string expression = 1;
    optional bool descending = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TObjectOrderBy
{
    // List of expressions for ordering objects in response.
    repeated TObjectOrderByExpression expressions = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TIndex
{
    // Index identity.
    optional string name = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqSelectObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to select.
    optional {{ data_model_proto_package }}.EObjectType object_type = 2;

    // Provides means for filtering certain objects.
    optional TObjectFilter filter = 3;

    // Provides means for filtering objects on master side.
    // May be useful with `enable_partial_result` option
    // for selecting rare objects.
    optional TObjectFilter postfilter = 13;

    // Describes which attributes to fetch.
    // TRspSelectObjects.results.attributes will contain exactly this number of attributes.
    optional TAttributeSelector selector = 4;

    // Enables limiting the number of results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectLimit limit = 5;

    // Enables skipping a number of leading results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectOffset offset = 6;

    // Format to use in response.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 7;

    // Request options.
    optional TSelectObjectsOptions options = 8;

    optional TObjectOrderBy order_by = 9;

    // If present joins object table with the given index table
    // for better performance in case of high query selectivity.
    optional TIndex index = 10;

    // Common request options.
    optional TCommonRequestOptions common_options = 11;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 12;
}

message TRspSelectObjects
{
    // The result set: each element of this list corresponds to a single
    // matching object.
    repeated TAttributeList results = 1;

    // If TReqSelectObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqSelectObjects.timestamp.
    optional uint64 timestamp = 2;

    // Continuation token should be sent in subsequent requests to fetch the next batch
    // of objects. Opaque for the client.
    optional string continuation_token = 3;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TAggregateExpressions
{
    repeated string expressions = 1;
}

message TGroupByExpressions
{
    repeated string expressions = 1;
}

message TReqAggregateObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to select.
    optional {{ data_model_proto_package }}.EObjectType object_type = 2;

    // Provides means for filtering certain objects.
    optional TObjectFilter filter = 3;

    // Group by expression.
    optional TGroupByExpressions group_by_expressions = 4;

    // Aggregate expressions.
    optional TAggregateExpressions aggregate_expressions = 5;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 6;

    // Common request options.
    optional TCommonRequestOptions common_options = 7;

    // See TSelectObjectsOptions.
    optional bool fetch_finalizing_objects = 8;
}

message TRspAggregateObjects
{
    // The result set: each element of this list corresponds to a single group of objects and its aggregation.
    // List is ordered as follows:
    //     1) group-by keys ordered according to group_by_expressions;
    //     2) aggregated values ordered according to aggregate_expressions.
    repeated TAttributeList results = 1;

    // If TReqAggregateObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqAggregateObjects.timestamp.
    optional uint64 timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCheckObjectPermissions
{
    message TSubrequest
    {
        // Use exactly one of the two following fields.
        // Id of the object to check, if the type has a single string id field.
        optional string object_id = 1 [deprecated = true];
        // A subset of the object's /meta identifying the object to check.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 6;

        // Type of the object to check.
        optional {{ data_model_proto_package }}.EObjectType object_type = 2;

        // Id of subject accessing the object (either user or group).
        optional string subject_id = 3;

        // Permission to check.
        optional {{ data_model_proto_package }}.EAccessControlPermission permission = 4;

        // Attribute path to check.
        optional string attribute_path = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 2;

    // Common request options.
    optional TCommonRequestOptions common_options = 3;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 4;
}

message TRspCheckObjectPermissions
{
    message TSubresponse
    {
        // Was request allowed or declined?
        optional {{ data_model_proto_package }}.EAccessControlAction action = 1;

        // The object whose ACL contains the matching ACE. Can be null.
        optional string object_id = 2;

        // The type of object referred by object_id. Can be null.
        optional {{ data_model_proto_package }}.EObjectType object_type = 3;

        //! Subject to which the decision applies. Can be null.
        optional string subject_id = 4;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqCheckObjectPermissions.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqCheckObjectPermissions.timestamp.
    optional uint64 timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjectAccessAllowedFor
{
    message TSubrequest
    {
        // Use exactly one of the two following fields.
        // Id of the object to check, if the type has a single string id field.
        optional string object_id = 1 [deprecated = true];
        // A subset of the object's /meta identifying the object to check.
        optional NYT.NOrm.NClient.NProto.TPayload meta = 6;

        // Type of the object to check.
        optional {{ data_model_proto_package }}.EObjectType object_type = 2;

        // Permission to check.
        optional {{ data_model_proto_package }}.EAccessControlPermission permission = 4;

        // Attribute path to check.
        optional string attribute_path = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation for a transactional data.
    // If omitted then reads the latest state.
    //
    // Note that the method operates not only with a transactional data,
    // but with a cached data too, e.g. users/groups and their relations are cached for now.
    // Cached data is not affected by the timestamp in any way.
    optional uint64 timestamp = 2;

    // Transaction id to determine start timestamp.
    // Used when timestamp is not defined.
    // The request must be sent to the master owning the transaction.
    optional string timestamp_by_transaction_id = 3;

    // Common request options.
    optional TCommonRequestOptions common_options = 4;
}

message TRspGetObjectAccessAllowedFor
{
    message TSubresponse
    {
        // Ids of users that are granted access.
        repeated string user_ids = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObjectAccessAllowedFor.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqGetObjectAccessAllowedFor.timestamp.
    optional uint64 timestamp = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetUserAccessAllowedTo
{
    message TSubrequest
    {
        // Id of the user to check.
        optional string user_id = 1;

        // Type of the object to check.
        optional {{ data_model_proto_package }}.EObjectType object_type = 2;

        // Permission to check.
        optional {{ data_model_proto_package }}.EAccessControlPermission permission = 3;

        // Attribute path to check.
        optional string attribute_path = 6;

        // Provides means for filtering certain objects.
        optional TObjectFilter filter = 7;

        // Continuation token indicates the next record to be fetched. Opaque for the client.
        optional string continuation_token = 4;

        // Maximum number of results to fetch.
        optional int32 limit = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;
}

message TRspGetUserAccessAllowedTo
{
    message TSubresponse
    {
        // Ids of objects to which user is granted permission.
        repeated string object_ids = 1;

        // Continuation token should be sent in subsequent requests to fetch the next batch
        // of objects. Opaque for the client.
        optional string continuation_token = 2;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqWatchObjects
{
    // Only fetches events with timestamp <= given timestamp.
    optional uint64 timestamp = 1;

    // Only fetches events with timestamp > start_timestamp.
    optional uint64 start_timestamp = 2;

    // Fetches events from the earliest offset available.
    // NB! This option does not provide consistent snapshot of all events that happened during the first timestamp read.
    optional bool start_from_earliest_offset = 13;

    // Token to continue object selection. Fetches events after previous replied events.
    // Either start_timestamp or continuation_token should be specified in request.
    optional string continuation_token = 3;

    // Type of objects to watch.
    optional {{ data_model_proto_package }}.EObjectType object_type = 4;

    // Enables limiting the number of results.
    // NB: May be unreachable when using filters and |read_time_limit|.
    optional int64 event_count_limit = 5;

    // If some events are already available, WatchObjects call just returns them.
    // Otherwise it waits up to |time_limit| if given.
    // NB: Only works together with the |timestamp| option.
    optional google.protobuf.Duration time_limit = 6;

    // Limits time spent on reading events from watch log table.
    // Returns fetched events that has been selected to moment
    // when given time limit is reached even if |event_count_limit| is not fulfilled.
    // Relevant only while using filters.
    optional google.protobuf.Duration read_time_limit = 19;

    // Provides means for filtering certain events based on the object attributes
    // at the moment of the event generation.
    //
    // Enabled for certain object types specified in the master configuration.
    // Returns an error for a disabled type.
    optional TObjectFilter filter = 7;

    // Events of the type "object_updated" in the response "should" contain at least one
    // changed attribute from the selector.
    //
    // Note, that the attribute change is not guaranteed: some events can be spurious in the sense that
    // their underlying attribute data was not changed at the event time.
    // Examples of attributes without changes-tracking and so with potentially high rate of spurious events:
    //   - Evaluated attributes: /<object>/control;
    //   - Attributes of unspecified size: /node/status/pod_ids; /<object>/annotations.
    //
    // Enabled for certain object types and certain attribute paths specified in the master configuration.
    // Returns an error for a disabled type or attribute path.
    optional TAttributeSelector selector = 8;

    // Read events from the given tablets specified as indexes within the range [0..tablet count).
    // If the list is empty, read events from all tablets.
    // Returns an error for tablet index that out of range.
    repeated int32 tablets = 9;

    // Format to use in response. None will respond with serialized key in object_id. Yson or proto
    // will leave it empty and fill meta with /meta of the object.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 10;

    // Specifies watch log to read from.
    // May be useful for testing and debugging purposes.
    optional string watch_log = 11;

    // Allows to skip trimmed rows (if any) and continue watching from the first non-trimmed one.
    // If continuation token became obsolete, this option allows to still read using it.
    optional bool skip_trimmed = 12;

    // Common request options.
    optional TCommonRequestOptions common_options = 14;

    // Fetch information about which attributes were changed by the event.
    optional bool fetch_changed_attributes = 15;

    // May be useful for debugging.
    optional bool fetch_event_index = 16;

    // Update event is selected from watchlog if it has at least one changed field that passes the tag filter.
    // A field passes the tag filter if it has at least one required tag and no excluded tags.
    // List of required tags.
    repeated int32 required_tags = 17;
    // List of excluded tags.
    repeated int32 excluded_tags = 18;
}

message TRspWatchObjects
{
    // Events read so far.
    // If less than |event_count_limit| returned, than all events up to |timestamp| were read.
    repeated TEvent events = 1;

    // If TReqWatchObjects.timestamp is missing, then this contains the actual timestamp.
    // Used for reading the DB; otherwise this is just the copy of TReqWatchObjects.timestamp.
    optional uint64 timestamp = 2;

    // Token to continue object selection.
    // Continuation is finished, if the response event count is smaller than the requested event count limit.
    optional string continuation_token = 3;

    // Returns the number of skipped rows.
    // Can be positive only if skipping is allowed, e.g. TReqWatchObjects.skip_trimmed = true.
    optional uint64 skipped_row_count = 4;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 5;

    message TChangedAttributeEntry
    {
        optional string attribute_path = 1;
    }

    // Mapping for decoding changed_attributes_summary layout.
    // Each entry corresponds to the character in the summary with the same index.
    repeated TChangedAttributeEntry changed_attributes_index = 6;
}

////////////////////////////////////////////////////////////////////////////////

message TTimeInterval
{
    // Time selector of form "begin <= time < end".
    // If some of the fields are not set the corresponding inequality is vacuous.

    // Left endpoint of the time interval. Endpoint is included.
    optional google.protobuf.Timestamp begin = 1;

    // Right endpoint of the time interval. Endpoint is not included.
    optional google.protobuf.Timestamp end = 2;
}

// Same as time interval, but instead of physical time timestamps are provided.
message TTImestampInterval
{
    optional uint64 begin = 1;
    optional uint64 end = 2;
}

enum ESelectObjectHistoryIndexMode
{
    HIM_DEFAULT = 0
    [(NYT.NYson.NProto.enum_value_name) = "default"];

    HIM_ENABLED = 1
    [(NYT.NYson.NProto.enum_value_name) = "enabled"];

    HIM_DISABLED = 2
    [(NYT.NYson.NProto.enum_value_name) = "disabled"];
}

message TSelectObjectHistoryOptions
{
    // Uuid of the object. If present, history will be selected for
    // object with given object_key and given uuid. Deprecated; fill request.meta instead.
    //
    // NB! Query will be inefficient if uuid is provided and |use_uuid_in_history_key| is false.
    optional string uuid = 1 [deprecated = true];

    // Maximum number of results to fetch.
    optional int32 limit = 2;

    // Continuation token - should be sent in subsequent requests to fetch the next batch
    // of history events. Opaque for the client.
    optional string continuation_token = 3;

    // Time interval to select.
    optional TTimeInterval interval = 4;

    // Timestamp interval to select.
    // Cannot be used together with |interval|.
    optional TTImestampInterval timestamp_interval = 9;

    // By default, it is forbidden to pass physical time to database with logical time layout and vice versa.
    // If true, allows to convert passed time to database time format.
    // NB! Time conversion between logical and physical is inaccurate, so extra events might appear in the response.
    optional bool allow_time_mode_conversion = 10;

    // If true, then order history by descending time.
    optional bool descending_time_order = 5;

    // If true, then skips consecutive events equal in data fields (event type, results, history
    // enabled attributes, etc).
    optional bool distinct = 6;

    // If true then all requested attributes will be merged into
    // root object corresponding to the object type.
    optional bool fetch_root_object = 7;

    // By default, best-effortly tries to use index based on configuration.
    // If enabled, then uses index even if it is in building mode.
    // If disabled, then uses plain history algorithm.
    //
    // Still requires index to fit the query.
    // May be useful for testing and debugging purposes.
    optional ESelectObjectHistoryIndexMode index_mode = 8;

    // Provides means for filtering certain events by value.
    // Filtering is applied before |distinct| option.
    // NB: Keep in mind, that if referenced attribute is not available in history event, it would be replaced by null.
    optional string filter = 11;

    // Controls event equality. See |distinct|.
    // Considered equal to |selector| if not specified.
    optional TAttributeSelector distinct_by = 12;
}

message TReqSelectObjectHistory
{
    // Type of the object to fetch the history for.
    optional {{ data_model_proto_package }}.EObjectType object_type = 1;

    // Use exactly one of the two following fields.
    // Id of the object to fetch the history for, if the type has a single string id field.
    optional string object_id = 2 [deprecated = true];
    // A subset of the object's /meta identifying the object to fetch history for.
    //
    // NB! Query will be inefficient if uuid is provided and |use_uuid_in__key| is false on history table.
    optional NYT.NOrm.NClient.NProto.TPayload meta = 6;

    // Describes which attributes are to be fetched.
    // TRspSelectObjectHistory.events.results will contain exactly this number of attributes.
    optional TAttributeSelector selector = 3;

    // Format to use in response.
    // Format must be supported in the moment of the query.
    optional NYT.NOrm.NClient.NProto.EPayloadFormat format = 4;

    // Object history selection query options.
    optional TSelectObjectHistoryOptions options = 5;

    // Common request options.
    optional TCommonRequestOptions common_options = 7;
}

message TRspSelectObjectHistory
{
    message TEvent
    {
        // Time of the event.
        optional google.protobuf.Timestamp time = 1;

        // Timestamp of the event.
        optional uint64 timestamp = 7;

        // Type of the event.
        optional EEventType event_type = 2;

        // User that has performed the change.
        optional string user = 3;
        // Provides an additional annotation to differentiate between
        // various clients that authenticate via the same effective user.
        optional string user_tag = 8;

        // Event attributes (cf. TReqSelectObjectHistory.selector).
        optional TAttributeList results = 4;

        // List of attributes that were stored for this event.
        repeated string history_enabled_attributes = 5;

        // Transaction context (see TReqStartTransaction).
        optional TTransactionContext transaction_context = 6;
    }

    // Selected events.
    repeated TEvent events = 1;

    // Continuation token.
    optional string continuation_token = 2;

    // Performance statistics for transparency if requested.
    optional TPerformanceStatistics performance_statistics = 3;

    // Physical time of last trim of history events.
    // Events before it are not accessible.
    optional google.protobuf.Timestamp last_trim_time = 4;
}

////////////////////////////////////////////////////////////////////////////////

service ObjectService
{
    // Generates a fresh monotonically increasing timestamp.
    rpc GenerateTimestamp (TReqGenerateTimestamp) returns (TRspGenerateTimestamp);

    // Starts a new transaction.
    // Transaction ids are opaque strings.
    // Transaction changes are transient (until commit); transactions are maintained by individual masters.
    // Clients must be choosing masters in a sticky way; cf. GetMasters.
    rpc StartTransaction (TReqStartTransaction) returns (TRspStartTransaction);

    // Commits an existing transaction.
    rpc CommitTransaction (TReqCommitTransaction) returns (TRspCommitTransaction);

    // Aborts an existing transaction.
    rpc AbortTransaction (TReqAbortTransaction) returns (TRspAbortTransaction);

    // Creates a new object.
    rpc CreateObject (TReqCreateObject) returns (TRspCreateObject);

    // Creates new objects.
    rpc CreateObjects (TReqCreateObjects) returns (TRspCreateObjects);

    // Removes an existing object.
    rpc RemoveObject (TReqRemoveObject) returns (TRspRemoveObject);

    // Removes existing objects.
    rpc RemoveObjects (TReqRemoveObjects) returns (TRspRemoveObjects);

    // Updates an existing object.
    rpc UpdateObject (TReqUpdateObject) returns (TRspUpdateObject);

    // Updates existing objects.
    rpc UpdateObjects (TReqUpdateObjects) returns (TRspUpdateObjects);

    // Fetches object attributes by object id.
    rpc GetObject (TReqGetObject) returns (TRspGetObject);

    // Fetches objects attributes by object ids.
    rpc GetObjects (TReqGetObjects) returns (TRspGetObjects);

    // Executes a query and fetches attributes for relevant objects.
    rpc SelectObjects (TReqSelectObjects) returns (TRspSelectObjects);

    // Executes a group-by query and aggregates attributes for relevant objects.
    rpc AggregateObjects (TReqAggregateObjects) returns (TRspAggregateObjects);

    // Runs permission checks for given objects, permissions, and users.
    rpc CheckObjectPermissions (TReqCheckObjectPermissions) returns (TRspCheckObjectPermissions);

    // Given objects and permissions, computes the set of users that are granted the specified permission.
    rpc GetObjectAccessAllowedFor (TReqGetObjectAccessAllowedFor) returns (TRspGetObjectAccessAllowedFor);

    // Computes the set of objects of a given type to which given users are granted given permissions.
    rpc GetUserAccessAllowedTo (TReqGetUserAccessAllowedTo) returns (TRspGetUserAccessAllowedTo);

    // Reads updates from event queue.
    rpc WatchObjects (TReqWatchObjects) returns (TRspWatchObjects);

    // Executes a query and fetches attributes for relevant objects.
    rpc SelectObjectHistory (TReqSelectObjectHistory) returns (TRspSelectObjectHistory);
}

////////////////////////////////////////////////////////////////////////////////
