# Сценарии YtSync
## Введение
Базово `YtSync` устроен следующим образом:
* через вызов методов `add_desired_table()`/`add_desired_consumer()`
строится ожидаемая модель базы (описание модели лежит [здесь](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/model))
* для всех таблиц/консьюмеров запрашиваются их атрибуты, и строится актуальная модель базы (код живет в классе
  [ActualStateBuilder](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/state_builder.py))
* по имени сценария ищется его реализация (имя сценария задается в атрибуте класса `SCENARIO_NAME`)
* реализация должна наследовать класс [ScenarioBase](https://a.yandex-team.ru/arcadia/yt/yt_sync/scenario/base.py)
* в сценарий передаются экземпляры `YtDatabase` для ожидаемого и актуального состояния базы, настройки
  [Settings](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/settings.py), и экземпляр
  [YtClientFactory](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/client.py)
* вызывается метод `setup`, в который передаются параметры сценария - прокидываются аргументы метода `YtSync.sync()`
* вызывается метод `run`, в котором выполняется вся работа (реализован в базовом классе)
* наследник класса `ScenarioBase` должен реализовать метод `generate_actions()`, который возвращает набор
  действий, которые должны быть выполнены над таблицами базы в рамках сценария (см.
  [здесь](https://a.yandex-team.ru/arcadia/yt/yt_sync/action) код действий). Действия над таблицами могут выполняться
  параллельно через батчевый клиент YT, поэтому группируются в батчи (см.
  [ActionBatch](https://a.yandex-team.ru/arcadia/yt/yt_sync/action/base.py))

## Сценарии, поддержанные в YtSync
### dump_diff
Пишет в лог дифф между актуальным и ожидаемым состоянием. Если дифф присутствует, то он логгируется с уровнем `WARNING`.
Если есть какие-то несовместимые изменения, они логгируются с уровнем `ERROR`.
#### Настройки из Settings
* `allow_table_full_downtime` - выводить ли изменения схемы, приводящие к полному downtime таблицы как ошибку
* `ensure_collocation` - выводит дифф для коллокаций
* `managed_roots` - список корневых папок, в поддеревьях которых ищутся неиспользуемые объекты (указывается для каждого
кластера отдельно или через `'default'` при отсутствии кластера в этом списке)
#### Параметры сценария
Отсутствуют.

### dump_spec
Пишет в вывод спецификацию всех таблиц ожидаемого состояния базы.
#### Настройки из Settings
Отсутствуют.
#### Параметры сценария
* `out` - файл, куда пишется спека (по-умолчанию `sys.stdout`)

### clean
(Пере)создает таблицы и консьюмеры базы. Если таблицы существовали ранее - они будут отмонтированы и удалены перед
тем как создать новые. Рекомендуется когда нужно (пере)создать чистую базу (работает для этого случая быстрее чем
`ensure*`).

#### Настройки из Settings
* `ensure_folders` - проверить и создать необходимые YT-папки для таблиц, если необходимые папки будут отсутствовать,
то сценарий завершится ошибкой
* `ensure_collocation` - добавить таблицы в коллокацию (если они помечены соответствующим образом)
* `collocation_name` - имя коллокации (можно задать только одно на базу и пометить таблицы, которые должны быть
  добавлены в коллокацию)
* `ensure_db_consumers` - создать нативные консьюмеры (если были добавлены через `add_desired_consumer`) и
  зарегистрировать в них очереди
#### Параметры сценария
Отсутствуют.

### ensure_attributes|ensure|ensure_heavy
Синхронизирует между собой актуальное и ожидаемое состояние базы:
* создает недостающие в актуальном состоянии федерацию таблиц, работает в `ensure` и `ensure_heavy`
* частный случай: создает отсутствующие мастер-таблицы (реплицированные или хаосные) если все таблицы-реплики на месте
  и совместимы между собой (схема совпадает), работает в `ensure` и `ensure_heavy`
* синхронизирует атрибуты таблиц (все сценарии)
* синхронизирует схемы таблиц
  * добавление колонок через `ensure` и `ensure_heavy`
  * удаление колонок, смена ключа через `ensure_heavy`
* синхронизирует регистрации очередей в нативных консьюмерах (все сценарии)
* синхронизирует коллокацию таблиц (все сценарии)

Для хаосной инсталляции на время работы сценария RTT для таблиц отключается!

#### Настройки из Settings
* `always_async` - набор всегда асинхронных реплик (в процессе работы сценария их нельзя делать синхронными)
* `allow_table_full_downtime` - разрешать ли изменения схемы с полным downtime таблицы (если нет, сценарий завершится ошибкой)
* `min_sync_clusters` - минимальное количество синхронных реплик, которые должны оставаться синхронными в процессе
  выполнения сценария
* `ensure_folders` - проверить и создать необходимые YT-папки для таблиц, если необходимые папки будут отсутствовать,
  то сценарий завершится ошибкой
* `ensure_collocation` - добавить таблицы в коллокацию (если они помечены соответствующим образом)
* `collocation_name` - имя коллокации (можно задать только одно на базу и пометить таблицы, которые должны быть
  добавлены в коллокацию)
* `ensure_db_consumers` - создать нативные консьюмеры (если были добавлены через `add_desired_consumer`) и
  зарегистрировать в них очереди
* `ensure_tables_mounted` - монтирует и расфриживает все таблицы перед выполнением сценария (необходимо для успешного
  переключения синхронных реплик в процессе)
* `parallel_processing_for_unmounted` - можно ли выполнять параллельную обработку таблиц
* `batch_size_for_parallel` - сколько таблиц можно обрабатывать в сценарии параллельно, если параллельная
   обработка включена
* `wait_in_memory_preload` - ожидать пока in-memory таблицы будут загружены в память после примонтирования перед
  выполнением последующих действий над таблицами
* `wait_between_replica_switch_delay` - поспать перед тем как процессить следующую реплику, если при обработке
  текущей происходило отмонтирование таблиц
* `switch_replicas_mode_for_data_modification` - сделать все таблицы-реплики на текущем кластере асинхронными
  если требуется запуск тяжелых операций (для хаоса всегда `true`)
* `switch_replicas_mode_always` - сделать все таблицы-реплики на текущем кластере асинхронными, если требуется
  отмонтирование таблиц (для хаоса всегда `true`)

#### Параметры сценария
* `skip-attributes` - пропустить синхронизацию атрибутов таблиц (только в ensure)

### switch_replica
Задает синхронные реплики для всех таблиц в базе (для реплицированных и хаосных баз).
Для таблиц под RTT выставляет `replicated_table_options/preferred_sync_replica_clusters` и при необходимости
`replicated_table_options/max_sync_replica_count`, для таблиц не под RTT оперирует напрямую атрибутом `mode` у
объектов `table_replica`/`chaos_table_replica`.

#### Настройки из Settings
Отсутствуют.

#### Параметры сценария
* `desired_sync_replicas` - список кластеров-реплик, которые надо сделать синхронными
* `force_fix_preferred` - форсить выставление `preferred_sync_replica_clusters` у таблиц под
  RTT: текущие синхронные реплики определяются по `mode` у объектов `table_replica`/`chaos_table_replica`, и они
  могут расходится с тем, что указано в `preferred_sync_replica_clusters`
* `update_max_sync_replica_count` - выставлять параметр `replicated_table_options/max_sync_replica_count` для таблиц
  под RTT равный количеству указанных синхронных реплик

### reshard
Решардирует таблицы в соответствии с настройками из ожидаемого состояния.
Особенности:
* если включена балансировка таблетов на таблицы, то такая таблица не решардируется
* для очередей количество таблетов можно только увеличить
* хаосные таблицы типа `replication_log` пересоздаются с нужным количеством таблетов
* реплицированные таблиц типа `replicated_table` пересоздаются с нужным количеством таблетов

Для хаосной инсталляции на время работы сценария RTT для таблиц отключается!

#### Настройки из Settings
* `always_async` - набор всегда асинхронных реплик (в процессе работы сценария их нельзя делать синхронными)
* `min_sync_clusters` - минимальное количество синхронных реплик, которые должны оставаться синхронными в процессе
  выполнения сценария
* `ensure_collocation` - добавить таблицы в коллокацию (если они помечены соответствующим образом), необходимо для
  пересозданных логов репликации
* `collocation_name` - имя коллокации (можно задать только одно на базу и пометить таблицы, которые должны быть
  добавлены в коллокацию)
* `switch_replicas_mode_always` - сделать все таблицы-реплики на текущем кластере асинхронными, если требуется
  отмонтирование таблиц (для хаоса всегда `true`)
* `wait_in_memory_preload` - ожидать пока in-memory таблицы будут загружены в память после примонтирования перед
  выполнением последующих действий над таблицами
* `parallel_processing_for_unmounted` - можно ли выполнять параллельную обработку таблиц
* `batch_size_for_parallel` - сколько таблиц можно обрабатывать в сценарии параллельно, если параллельная
   обработка включена

#### Параметры сценария
Отсутствуют.

### sync_replicas
Добавляет/удаляет кластер с таблицами-репликами.
Удаление реплики:
* удаляет объект `table_replica`/`chaos_table_replica` для соответствующего кластера
* если указан параметр сценария `remove_tables`, то и таблицы с данными на кластере-реплике

Добавление реплики:
* таблицы на кластере-реплике должны отсутствовать (необходимость добавления определяется по отсутствию таблицы)
* объекты `table_replica`/`chaos_table_replica` тоже должны отсутствовать

Сортированные таблицы:
* таблицы копируются as is с кластера-источника с помощью `remote_copy`
* копируются все атрибуты таблицы с кластера источника, если в ожидаемом состоянии указаны другие атрибуты, их потом
  необходимо синхронизировать с помощью сценария `ensure`
* добавленная таблица-реплика шардируется так же как таблица-источник

Упорядоченные таблицы:
* создаются пустые с таким же количеством таблетов как и таблица-источник
* для таблицы задается начальный `trimmed_rows_count` таким образом, чтобы новые `$row_index`-ы совпадали в старой и
  новой таблицах-репликах

#### Настройки из Settings
* `always_async` - набор всегда асинхронных реплик, если не указан параметр сценария `source_cluster`, то используется
  для выбора реплики - источника.
* `ensure_folders` - проверить и создать необходимые YT-папки для таблиц, если необходимые папки будут отсутствовать,
  то сценарий завершится ошибкой
* `parallel_processing_for_unmounted` - можно ли выполнять параллельную обработку таблиц
* `batch_size_for_parallel` - сколько таблиц можно обрабатывать в сценарии параллельно, если параллельная
   обработка включена

#### Параметры сценария
* `source_cluster` - кластер-источник таблиц-реплик:
  * т.к. таблицы на кластере-источнике фризятся/отмонтируются, то желательно выбирать асинхронную реплику
  * если не указан, то порядок выбора такой: реплика из списка `Settings.always_async`, какая-нибудь асинхронная реплика
* `remove_tables` - удалять ли таблицы-реплики на кластере при удалени реплики

### force_compaction
Запускает форсированную компактификацию для сортированных таблиц в базе.
Сценарий прикапывает свой прогресс в YT, поэтому его можно останавливать и запускать заново.

#### Настройки из Settings
* `switch_replicas_mode_always` - сделать реплику асинхронной (если сейчас синхронная) перед запуском компактификации
  на ней

#### Параметры сценария
* `tablet_node_count` - количество tablet-нодов из бандла (можно указать меньше, чтобы компактификация шла медленее)
* `restart_compaction` - запустить процесс компактификации заново, даже если предыдущий запуск ещё не компактифицировал
  все таблицы
* `force_compact_filter` - фильтр на таблицы, которые должны подвергаться компактификации (чтобы компактифицировать
  не все таблицы в базе)
* `force_compact_clusters` - компактифицировать таблицы не на всех кластерах базы, а только на указанных

### migrate_to_replicated
Смигрировать standalone инсталляцию на реплицированную. Сортированные таблицы копируются на кластера-реплики с
помощью `remote_copy`, упорядоченные (очереди) создаются заново. Вместо standalone таблиц создаются реплицированные.

#### Настройки из Settings
Отсутствуют.

#### Параметры сценария
Отсутствуют.

### migrate_to_chaos
Смигрировать реплицированную инсталляцию в хаосную. Реплицированные таблицы фризятся, потом удаляются после того
как лаг репликации сошелся в 0. На их месте создаются хаосные реплицированные таблицы. Таблицы реплики отмонтируются,
им проставляется новый `tablet_cell_bundle` и `upstream_replica_id`. Так же создаются пустые таблицы типа
`replication_log`.

#### Настройки из Settings
Отсутствуют.

#### Параметры сценария
Отсутствуют.

### remount
Запускает перемонтирование таблиц в базе с помощью последовательных unmount и mount.

#### Настройки из Settings
Отсутствуют.

#### Параметры сценария
* `cluster` - ограничивает применение только указанным кластером
* `parallel` - запустить процесс для нескольких таблиц в параллель
* `parallel_batch_size` - размер батча при параллельной обработке

### move
**ВАЖНО**: сценарий не предназначен для использования на хаосной инсталляции.

Перемещает ноды и таблицы из модели, заданные через `add_desired_*`, согласно переданной конфигурации из
папки-источника (`source`) в папку-назначение (`destination`) по такому же относительному пути. Состояние объектов:
* если объект есть только в поддереве `source`, то он перемещаться в поддерево `destination` по такому же относительному
пути
* если объект есть только в поддереве `destination`, то при соответствии типов (и реплик в случае реплицированной
таблицы) объект игнорируется
* если объекта нет ни в одном поддереве, то сценарий завершается с ошибкой конфигурации
* если объект есть и в поддереве `source`, и в поддереве `destination`, то ошибка, если это не ссылка или
реплицированная таблица. В противном случае объекты сверяются и в случае соответствия объект из `source` удаляется.

Дополнительные особенности:
* [федерация таблиц](https://yt.yandex-team.ru/docs/user-guide/dynamic-tables/replicated-dynamic-tables) может быть
перемещена как целиком, так и частично
* сценарий не удаляет папки из `source`, только лишь создает соответствующие им по относительным путям в `destination`
* если `target_path` ссылки из модели лежит в поддереве `source`, то он тоже будет изменен на соответствующий путь в
поддереве `destination` вне зависимости от того, будет ли ссылка перемещена
* пути `source` и `destination` для кластера `cluster_name` получаются из обязательного параметра сценария (см. ниже).
Если `cluster_name` отсутствует в конфигурации, то пути берутся для значения `default`

При ошибке во время исполнения сценария с корректной конфигурацией можно его перезапустить для попытки продолжения
работы. Рекомендуется запустить `ensure` на перемещенных объектах.

#### Настройки из Settings
* `ensure_folders` - производить перемещение нод и создание необходимых папок. Если указано как `False`, то папки не
создаются и перемещаются только таблицы.

#### Параметры сценария
* __`destination_config`__ - конфигурация для перемещения
  > Структура: `[cluster_name -> (source, destination)]`, где `cluster_name` - это название кластера или `default`.

### drop_unmanaged
Удалить неиспользуемые таблицы и ноды. Удаление происходит только из корневых папок, содержащих хотя бы один объект из
модели. На каждом из указанных в модели кластеров должна быть хотя бы одна из корневых папок, из которой будет
происходить удаление.

Дополнительные особенности:
* на текущий момент все ноды, кроме папок, сохраняются
* [федерация таблиц](https://yt.yandex-team.ru/docs/user-guide/dynamic-tables/replicated-dynamic-tables) может быть
удалена как целиком, так и частично, если некоторые реплики не существуют, но их пути входят в список корневых папок,
из которых будет происходить удаление
* если таблица-реплика является неиспользуемой, но соответствующей реплицированной таблицы нет ни в модели, ни среди
корневых папок, из которых будет происходить удаление, то данная таблица все равно удаляется

#### Настройки из Settings
* `managed_roots` - список корневых папок, в поддеревьях которых ищутся неиспользуемые объекты (указывается для каждого
кластера отдельно или через `'default'` при отсутствии кластера в этом списке)

#### Параметры сценария
* `drop_nodes` - удалять ли ноды, по умолчанию `False`
