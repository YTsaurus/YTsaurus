# Настройки YtSync
Настройки живут в классе [`Settings`](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/settings.py).

Обязательным полем в настройках является `db_type` (тип базы):
- `REPLICATED_DB` - если работаем с нехаосной базой (неважно, standalone или реплицированные таблицы)
- `CHAOS_DB` - если работаем с хаосной базой

Другие настройки:
- `min_sync_clusters: int = 1`
  > `YtSync` в процессе накатывания изменений может менять у реплик режим с синхронного на
  > асинхронный и обратно, данная настройка регулирует минимальное количество синхронных реплик, которое должно
  > поддерживаться в процессе переключения. Актуально только для инсталляций с репликами (реплицированные таблицы, или
  > хаосные инсталляции). Значение по умолчанию равно `1`.
- `always_async: set[str] = {}`
  > Названия кластеров, реплики на которых никогда не должны переходить в синхронный режим в процессе работы `YtSync`.
- `switch_replicas_mode_always: bool = False`
  > Всегда переключать реплики для кластера в асинхронный режим, если на кластере планируется отмонтирование таблиц
  (для `alter_table`/обновления атрибутов/решардирования). Обычно такие изменения довольно быстрые, таблица в отмонтированном
  состоянии находится недолго, соответственно, downtime будет меньше, чем при переключении синхронной реплики. Тем не
  менее, может быть ситуация, когда даже такие операции занимают много времени (например, большая таблица, при
  монтировании поднимается в память), в такой ситуации эту настройку лучше включить в `True`.
- `switch_replicas_mode_for_data_modification: bool = True`
  > Всегда переключать реплики в асинхронный режим, если если на кластере планируется запускать `map`/`sort` операции.
  Обычно такие операции занимают слишком много времени, поэтому downtime на переключение реплики в синхронный режим
  будет сильно короче, чем пока отрабатывает `map`/`sort`.
- `wait_in_sync_replicas: bool = True`
  > Когда переключаем какую-то из реплик в синхронный режим - нужно ли дождаться когда реплика переключилась перед тем
  как запускать следующие операции.
- `ensure_folders: bool = False`
  > Перед запуском `clean` или `ensure*` сценария убедиться, что все папки, в которых лежат таблицы базы, существуют
  (если нет - будут созданы).
- `managed_roots: dict[str, list[str]]`
  > Корневые папки, из которых запускается поиск неиспользуемых нод и таблиц в сценариях `dump_diff` и `drop_unmanaged`, в
  формате `[cluster_name -> [roots]]`. Не допускается вложенность корней на одном кластере. В качестве имени кластера можно
  использовать `'default'`, пути из которого берутся в случае, если имя кластера отсутствует в `managed_roots`.
- `parallel_processing_for_unmounted: bool = False`
  > Только для сценариев `ensure`/`ensure_heavy`/`reshard`: модифицировать таблицы на кластере параллельно или последовательно.
  Параллельный запуск может сильно ускорить общее время работы сценария, но следует использовать с осторожностью:
  большое количество таблиц может оказаться одновременно отмонтированными, так же может запуститься параллельно много
  `map`/`sort` операций. Количество параллельно обрабатываемых таблиц можно настроить через параметр `batch_size_for_parallel`.
- `batch_size_for_parallel: dict[str, int]`
  > Количество параллельно обрабатываемых таблиц при настройке `parallel_processing_for_unmounted=True`
  Задается отдельно для каждого сценария. Если для конкретного сценария не определено, то значение берется для фейкового
  сценария `default`, если нет значения и для `default`, то значение равно 0 - нет лимита на размер батча. Если указать
  размер батча равный 1, то поведение будет такое же, как при `parallel_processing_for_unmounted=False` - все таблицы
  обрабатываются последовательно.
- `use_fake_actual_state_builder: bool = False`
  > __Для использования только в тестах__. Не опрашивает реальные YT таблицы для построения модели актуальной базы, все
  таблицы в актуальной базе - копии из желаемой базы, помеченные как несуществующие. Экономит немного времени, когда в
  функциональных тестах создаем пустую базу через сценарий `clean`.
- `operations_spec: dict[str, dict] = dataclass_field(default_factory=dict)`
  > YT спека для длинных операций. Задается для каждого кластера и операции индивидуально.
  Пока поддержаны для операций `run`, `map`, `remote_copy`.
  Можно задавать спеки по умолчанию для кластера и операции через секцию `default`.
  Получение правильной спеки должно происходит через метод `Settings.get_operation_spec()`: если спека не указана ни
  напрямую, ни через дефолты, то:
  * для `map` возвращается `Settings.DEFAULT_MAP_SPEC`
  * для `sort` возвращается `Settings.DEFAULT_SORT_SPEC`
  * для `remote_copy` возвращается `Settings.DEFAULT_REMOTE_COPY_SPEC`.

  Пример:
  ```python
  settings.operations_spec = {
      "default": {"map": {"from": "default"}, "sort": {"from": "default"}},
      "cluster1": {"map": {"from": "cluster1"}, "sort": {"from": "cluster1"}},
      "cluster2": {"remote_copy": {"from": "cluster2"}},
  }

  assert settings.get_operation_spec("cluster1", "map")["from"] == "cluster1"
  assert settings.get_operation_spec("cluster1", "sort")["from"] == "cluster1"
  assert settings.get_operation_spec("cluster1", "remote_copy") == Settings.DEFAULT_REMOTE_COPY_SPEC

  assert settings.get_operation_spec("cluster2", "map")["from"] == "default"
  assert settings.get_operation_spec("cluster2", "sort")["from"] == "default"
  assert settings.get_operation_spec("cluster2", "remote_copy")["from"] == "cluster2"
  ```
- `ensure_collocation: bool = False`
  > После того как отработают сценарии `clean`/`ensure*`/`reshard` убедиться, что все таблицы находятся в
    [коллокации](https://yt.yandex-team.ru/docs/user-guide/dynamic-tables/replicated-dynamic-tables#replication_collocation):
   - если коллокации нет, таковая будет создана
   - если таблица должна быть в коллокации, но не присутствует - будет добавлена в коллокацию
   - если таблица присутствует в коллокации, но не должна - будет удалена из коллокации
- `collocation_name: str | None = None`
  > Название коллокации (какое-то человекочитаемое название), обязано быть заполнено, если `ensure_collocation=True`.
- `max_operation_action_duration: int = 7200  # 2hrs`
  > Лимит на время action-а, запускающего длинные операции (типа `map`/`sort`).
- `wait_between_replica_switch_delay: int = 0`
  > Сколько нужно подождать перед обработкой таблиц на следующем кластере, если были какие-то модификации на текущем.
  Только для `ensure*` сценариев.
- `wait_in_memory_preload: bool = True`
  > Подождать, пока модифицированные таблицы будут загружены в память после монтирования перед обработкой таблиц на
  следующем. Только для `ensure*` сценариев.
- `allow_table_full_downtime: bool = True`
  > Разрешить изменения схемы с полным downtime таблицы (например, одновременное удаление и добавление колонки).
- `ensure_tables_mounted: bool = True`
  > Убедиться что все таблицы примонтированы (`tablet_state == mounted`) перед выполнением сценария `ensure*`.
  Если по какой-то причине таблицы не могут быть примонтированы в данный момент, то эту настройку стоит выставить в `false`.
- `use_deprecated_spec_format: bool = True` - использовать формат спецификации, совместимый с ytsync v1.
  > Рекомендуется переехать на новый формат спецификации, который описан в коде
  [тут](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/spec/).
- `always_log_full_diff: bool = False`
  > Для всех сценариев всегда писать в лог полный дифф, а не только по изменениям, которые обрабатывает сценарий.
- `fix_implicit_replicated_queue_attrs: bool = True`
  > Добавляет атрибуты `preserve_tablet_index = true` и `commit_ordering = strong` для реплицированной/хаосной
  упорядоченной таблицы (очереди), если эти атрибуты не заданы явно в спецификации таблиц.
- `max_actual_state_builder_workers: int = 8`
  > Максимальное количество потоков, используемых для построения actual state.
  Нет смысла выставлять больше чем количество кластеров.
