# Спека стейджей

Это своеобразный easy mode для yt_sync.
Позволяет для большинства типовых случаев декларативно описать ваши сущности
(таблицы, очереди, консьюмеры, продюсеры, пайплайны)
и их отличия на разных стейджах (стейбл, престейбл, дев, CI-тесты).
И по этому описанию вызывать YtSync.

Начнем с примера:

{% code 'yt/yt_sync/runner/easy_mode/ut/stages_example.yaml' lang='yaml' %}

Пример, как может выглядеть [\_\_main\_\_.py](https://a.yandex-team.ru/arcadia/yt/yt_sync/example/easy_mode/__main__.py) {#run_yt_sync_easy_mode}

{% code 'yt/yt_sync/example/easy_mode/__main__.py' lang='python' %}

Аргументы функции `run_yt_sync_easy_mode` такие же как у [run_yt_sync](usage.md#run_yt_sync), отличается только формат описания стейджей (StagesSpec вместо Description).

## Общая схема работы

Вы описываете StagesSpec, это описание сущностей сразу для всех стейджей (стейбл/престейбл/...). <br>
Далее происходит несколько мерджей и немного приятной магии.

1) Каждый стейдж мерджится с дефолтным значением стейджа (confmerge c конкатенирующей логикой для `$merge_*` полей).
После этого стейджи обрабатываются независимо. То есть по сути это упрощение StagesSpec без изменения структуры.
1) Применяются стейджовые пресеты (описанные в `stages[stage]["presets"]` и через `$merge_presets`).
По сути это тоже упрощение StagesSpec. Пресеты исчезают, смердженные значения остаются.
1) Применяются кластерные пресеты, это специальные кластера `_all_clusters`, `_all_data_clusters` и другие `_*`.
После этого опять остается спека такого же формата, но уже без кластерных пресетов.
1) Заполняются поля path в сущностях, где они еще не были заполнены, как `<stage_folder>/<entity_name>`.
1) Упрощается поле `in_stage_queues` для консьюмеров,
находятся реальные пути этих очередей и дозаполняется поле `queues` в спеке консьюмеров.

И в конце у вас получается набор обычных YtSync-спек для всех сущностей, которые передаются ядру YtSync.

Зачем столько этапов и почему так сложно?
Чтобы все типовые сценарии использования можно было лаконично и понятно сконфигурировать.
Например, повесить специальные настройки на все таблицы, в которые идут лукапы.
Или включить ханки на одной таблице на одном их кластеров престейбла.
Или проставить в одном месте primary medium и быть уверенным, что он везде прорастет.

Дальше можно почитать детальнее про этапы этого процесса.

## Мердж стейджей

Мердж стейджей осуществляется с помощью confmerge c особой логикой для полей
`$merge_presets` и `$merge_clusters` (эти списки конкатенируются при мердже).

Примеры можно посмотреть в
[тестах](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/spec_merger/ut/test_preset_merger.py?rev=r15318671#L177)

{% code 'yt/yt_sync/core/spec_merger/ut/test_preset_merger.py' lang='python' lines='[BEGIN merge_stage_tests]-[END merge_stage_tests]' %}

## Мердж пресетов

Пресеты - это произвольные словарики, которые можно объявлять/оверрайдить в секции `presets` стейджей.
Пресеты могут вмердживать в себя другие пресеты в произвольных местах.
И в описаниях сущностей стейджа (таблиц/консьюмеров и т. д.) можно так же подмердживать пресеты в произвольных местах.
Тем не менее рекомендуется по возможности ограничиться подмердживанием пресетов
на уровнях описания сущностей, так будет проще не запутаться.

Чтобы уменьшить вероятность человеческих ошибок заведение новых пресетов разрешено только в дефолтном стейдже.
При этом оверрайдить пресеты можно и в реальных стейджах
(и тут, если пользователь слегка опечатается, то получит ошибку).

Так же есть встроенные пресеты, начинающиеся с "builtin:", их можно посмотреть
[тут](https://a.yandex-team.ru/arcadia/yt/yt_sync/runner/builtin_presets/__init__.py?rev=r15319420#L11).

{% code 'yt/yt_sync/runner/builtin_presets/__init__.py' lang='python' lines='[BEGIN builtin_presets]-[END builtin_presets]' %}

Их можно и нужно использовать для задания общих атрибутов сущностей (путем оверрайдов в стейджах на эти пресеты).

## Мердж кластерных пресетов

Самые важные кластерные пресеты:
* `_all_clusters` - подмердживается под все кластера.
* `_all_data_clusters` - подмердживается под все кластера с репликами или standalone таблицами
(и только для таблиц имеет смысл пользоваться этим пресетом).
* `_all_replicated_clusters` - подмердживается под все кластера с реплицированными таблицами.

Все кластерные пресеты должны начинаться с `_`, а их полный список можно посмотреть
[тут](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/spec_merger/stages_merger.py?rev=r15318671#L16).

{% code 'yt/yt_sync/core/spec_merger/stages_merger.py' lang='python' lines='[BEGIN cluster_presets]-[END cluster_presets]' %}

## Особенности описания для консьюмеров очередей

Есть специальное поле `in_stage_queues`, которое позволяет легко и лаконично
объявить регистрации консьюмера к нескольким очередям из того же стейджа.

Пример: `"in_stage_queues": {"<queue_key_from_stage_queues>": {"vital": True}}`

[Как это работает](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/spec_merger/ut/test_stages_merger.py?rev=r15321121#L284)
{% code 'yt/yt_sync/core/spec_merger/ut/test_stages_merger.py' lang='python' lines='[BEGIN in_stage_queues_test]-[END in_stage_queues_test]' %}

## Описание пайплайнов {#pipeline_description}

В большинстве случаев для описания пайплайна достаточно написать

```python
PIPELINES = {
    "pipeline": {  # Без явного указания `path` пайплайн будет создан по пути `<stage_folder>/pipeline`.
        "default": {
            "$merge_presets": ["builtin:pipeline_preset"],  # Дефолтный настройки таблиц подтянутся из пресета.
            "monitoring_project": "<monitoring_project>",
            "monitoring_cluster": "<monitoring_cluster>",
        },
    },
}
```

и заоверрайдить пресет `builtin:table_preset`,
чтобы таблицы пайплайна были на правильных кластерах, в правильном бандле и медиуме.

Если нужна более тонкая настройка - можно оверрайдить пресеты `builtin:pipeline_*`
или задавать нужные атрибуты в самом описании пайплайна.

[Пример тонкой настройки таблиц пайплайна](https://a.yandex-team.ru/arcadia/yt/yt_sync/core/spec_merger/ut/test_stages_merger.py?rev=r15318671#L354)


## Рекомендации
* По возможности переопределяйте один атрибут только в одном месте (или в минимально возможном количестве мест).
Сложная структура мерджей позволяет переопределить атрибут конечной таблицы минимум в 8 местах,
приоритизация между местами достаточно простая, но будет сильно проще, если об этом не нужно будет задумываться
* Определять primary cluster и medium в `builtin:storage_preset`. Этот пресет специально для этого сделан
* Определять `tablet_cell_bundle` в `builtin:table_preset`.
* Пресеты `builtin:consumer_preset`, `builtin:producer_preset`, `builtin:pipeline_*`
наследуют пресет `builtin:table_preset`, поэтому нужно осознанно оверрайдить `builtin:table_preset`.
Например, если вы хотите только свои пользовательские таблицы сделать реплицированными,
то стоит завести для них отдельный базовый пресет
унаследованный `builtin:table_preset`, и в этом пресете добавлять вторичные кластера.
* Заводите новые пресеты только в описании дефолтного стейджа,
это защитит вас от случайных опечаток и оверрайдов несуществующих стейджей
На самом деле эта рекомендация закреплена ассертами в коде и иначе вы не сможете :).
* Если у вас разного вида реплики у таблицы,
например на сенеках для лукапов и на хан-арнольде для мапредюсов, то имеет смысл завести
отдельный кластерный пресет для них `_all_mr_clusters` и в этом пресете определять настройки для таких кластеров.
Так как это не дефолтный пресет, то надо не забыть явно отнаследоваться от него в описаниях нужных кластеров.
