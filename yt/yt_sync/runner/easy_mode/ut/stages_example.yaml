# StagesSpec
{
  # Здесь описываем, какие у нас есть стейджи.
  "stages": {
    # Дефолт для всех стейджей, будет подмердживаться под описания всех стейджей.
    "default": {
      # Пресеты. Это общего вида именованные словарики, которые могут подмердживаться
      # в разные места в описаниях сущностей и в описаниях самих пресетов.
      "presets": {
        # Пресеты, имена которых начинаются с 'builtin:' - встроенные,
        # но на них можно накладывать оверрайды, что тут и происходит.
        # Самый базовый пресет для сущностей, предполагается, что тут
        # можно определить самые общие атрибуты для всех сущностей.
        "builtin:storage_preset": {
          # Здесь пошла общая часть обычной yt_sync-спеки для таблиц/нод.
          "clusters": {
            # Это встроенный кластерный пресет (не путать с обычными пресетами).
            # Его значение подмерджится под описания всех кластеров в рамках этой сущности.
            "_all_clusters": {
              # Собственно определяем атрибут нужный всем сущностям
              # - медиум где данные хранить.
              "attributes": {"primary_medium": "ssd_blobs"}
            },
          },
        },
        # Базовый пресет для всех таблиц. Он наследует builtin:storage_preset.
        # Тут можно определить атрибуты общие для всех таблиц
        # - как минимум это tablet_cell_bundle.
        "builtin:table_preset": {
          "clusters": {"_all_clusters": {"attributes": {"tablet_cell_bundle": "bundle"}}}
        },
        # Для больших пользовательских сортированных таблиц мы можем хотеть
        # иметь отдельный базовый пресет.
        # Тут мы пока его только объявляем,
        # а смысл будем добавлять уже в конкретных стейджах.
        "big_sorted_table_preset": {
          # Указываем, что этот пресет наследует другому.
          # Наследование тут множественное, а при мердже стейджей
          # эти $merge списки конкатенируются (особая логика для $merge полей).
          "$merge_presets": ["builtin:table_preset"]
        },
      },
    },
    # Стейбл, наш продакшн :)
    "stable": {
      # Корневая директория нашего стейбла.
      # Поверьте, лучше она будет одна на всех кластерах
      # (разные сделать возможно, но сложно и не нужно).
      "folder": "//home/my_awesome_project/stable",
      "presets": {
        # В самый базовый оверрайд добавляем кластер markov
        # как главный (имеет значения для реплицированных таблиц).
        # Заодно исправляем на нем бандл, так как там ssd называется default.
        "builtin:storage_preset": {"clusters": {"markov": {
          "main": true,
          "attributes": {"primary_medium": "default"}
        }}},
        # Для наших больших пользовательских таблиц скажем,
        # что они будут реплицированные - досыпем им кластер seneca-sas.
        "big_sorted_table_preset": {"clusters": {"seneca-sas": {}}},
      },
    },
    # Престейбл мы пропустим, чтобы не было слишком длинно.
    # Наш дев:
    "dev": {
      "folder": "//home/my_awesome_project/dev",
      "presets": {
        # Всё будет на зено.
        "builtin:storage_preset": {"clusters": {"zeno": {}}},
        # Тут мы не переопределяем big_sorted_table_preset, так что
        # пользовательские таблицы будут standalone - не реплицированными.
      },
    },
  },
  "tables": {
    # Описываем таблицу, по дефолту путь к ней будет <folder>/my_table
    "my_table": {
      # Для всех стейджей.
      "default": {
        # Наследуем пресет наших больших пользовательских таблиц.
        "$merge_presets": ["big_sorted_table_preset"],
        # Схема, куда ж без нее :)
        "schema": [
          {"name": "K", "type": "string", "sort_order": "ascending"},
          {"name": "V", "type": "string"},
        ],
      },
      # Для продакшн стейджа уточняем:
      "stable": {"clusters": {
        # Еще один встроенный кластерный пресет.
        # Будет подмержен под все кластера этой таблицы, на которых будут
        # располагаться сортированные таблицы - либо реплики, либо standalone.
        "_all_data_clusters": {"attributes": {"in_memory_mode": "uncompressed"}}
      }},
    },
    # Описываем очередь, aka упорядоченную таблицу.
    "my_queue": {
      "default": {
        "$merge_presets": ["builtin:table_preset"],
        "schema": [{"name": "V", "type": "string"}],
      },
    },
  },
  "consumers": {
    "my_consumer": {
      "default": {
        # Встроенный пресет консьюмера, он внутри себя
        # наследует builtin:table_preset для своей таблицы.
        "$merge_presets": ["builtin:consumer_preset"],
        "in_stage_queues": {"my_queue": {"vital": True}},
      },
    },
  },
  "producers": {"my_producer": {"default": {"$merge_presets": ["builtin:producer_preset"]}}},
}
