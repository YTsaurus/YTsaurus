# Атрибуты

В данном разделе собрана информация про атрибуты Кипариса.

## Общая информация { #common }

С каждым объектом в системе {{product-name}} связан набор **атрибутов**. Множество атрибутов представляет собой словарь ключ-значение, который доступен для чтения и изменения. Именами атрибутов могут выступать произвольные непустые строки. Значениями — произвольные [YSON](../../../user-guide/storage/yson.md)-структуры.

Атрибуты бывают двух видов: **[системные](#system_attr)** и **[пользовательские](#user_attr)**.

Для обращения к атрибутам объекта используется специальный модификатор пути `/@` и команды `get`, `list`, `set`, `remove`. Помимо обращения к атрибутам целиком можно адресовать их части (в случае, когда значение атрибута — составной тип).

Более подробную информацию про модификаторы пути можно найти в разделе [YPath](../../../user-guide/storage/ypath.md).

У команд `get` и `list` можно опционально указать список атрибутов, которые требуется вернуть вместе c найденными объектами.

## Системные атрибуты { #system_attr }

У разных типов объектов имеется свой набор системных атрибутов, специфичных для данного типа. Например, у любого объекта есть атрибут `id`, у таблиц есть атрибуты `compression_codec` и `compressed_data_size`. Подробнее про атрибуты, присущие всем объектам, можно почитать в разделе [Объекты](../../../user-guide/storage/objects.md).

Системные атрибуты бывают изменяемыми (может изменять пользователь), например `compression_codec`, и неизменяемыми, например `compressed_data_size`. При попытке установить неизменяемый атрибут система вернет ошибку. Попытка удаления системного атрибута также приведет к ошибке.

Некоторые атрибуты являются **наследуемыми**: такие атрибуты можно устанавливать на директориях (map-нодах), где они являются nullable, то есть могут не иметь (и не имеют по умолчанию) никакого значения. Если при создании нового объекта не указано значение наследуемого атрибута, данный атрибут получает значение ближайшего узла-предка или значение по умолчанию, если ни у одного предка вплоть до корня атрибут не установлен.

Для разных типов объектов наследуются разные множества атрибутов. Следующие атрибуты наследуются **таблицами, файлами и журналами:**
  - `chunk_merger_mode`;
  - `compression_codec`;
  - `enable_striped_erasure`;
  - `erasure_codec`;
  - `hunk_media`;
  - `hunk_primary_medium`;
  - `media`;
  - `primary_medium`;
  - `replication_factor`;
  - `vital`.

В дополнение к перечисленным, следующие атрибуты наследуются **только таблицами:**
  - `atomicity`;
  - `hunk_erasure_codec`;
  - `commit_ordering`;
  - `in_memory_mode`;
  - `optimize_for`;
  - `profiling_mode`;
  - `profiling_tag`;
  - `tablet_cell_bundle`.

**Реплицированные Хаосные таблицы** наследуют следующие атрибуты:
  - `chaos_cell_bundle`.

Также системные атрибуты могут быть **непрозрачными** (**вычисляемыми**, **opaque**), то есть их значение будет доступно только при явном запросе командой `get`, но не будет доступно (а точнее, значение атрибута будет равно **entity**) при запросе всех атрибутов. Чаще всего непрозрачными объявляются атрибуты, имеющие большое значение (в смысле объема данных), либо вычисление которых требует значительного времени.{% if audience == "public" %} То есть, если данные в атрибуте составляют более сотни килобайт, имеет смысл делать их непрозрачными. В таком случае при запросе всех атрибутов, они не будут возвращаться, и чтение всех атрибутов будет быстрее. Если требуется получить эти значения, нужно явно их запросить.{% endif %} Примером непрозрачного атрибута будет список всех чанков таблицы (атрибут `chunk_ids`) или суммарное использование ресурсов по поддереву Кипариса (атрибут `recursive_resource_usage`).

Ниже представлен список атрибутов объектов системы {{product-name}}:

- [атрибуты любого объекта](../../../user-guide/storage/objects.md#attributes);
- [атрибуты узлов Кипариса](../../../user-guide/storage/cypress.md#attributes);
- [атрибуты статических таблиц](../../../user-guide/storage/static-tables.md#attributes);
- [атрибуты динамических таблиц](../../../user-guide/dynamic-tables/overview.md#attributes);
- [атрибуты файлов](../../../user-guide/storage/files.md#attributes);
- атрибуты [compression_codec](../../../user-guide/storage/compression.md#get_compression) и [erasure_codec](../../../user-guide/storage/replication.md#erasure) для таблиц и файлов;
- [атрибуты транзакций](../../../user-guide/storage/transactions.md#attributes);
- [атрибуты ссылок](../../../user-guide/storage/links.md#attributes);
- [атрибуты аккаунтов](../../../user-guide/storage/accounts.md#account_attributes);
- [атрибуты медиумов](../../../user-guide/storage/media.md#atributy).

## Пользовательские атрибуты { #user_attr }

Пользователь может самостоятельно устанавливать произвольные атрибуты.

{% note warning "Внимание" %}

Имена (ключи) пользовательских атрибутов не должны совпадать с именами системных атрибутов. Рекомендуется начинать имена пользовательских атрибутов с подчеркивания, это позволит избежать потенциальных проблем при расширении множества системных атрибутов.

{% endnote %}

{% note warning "Внимание" %}

Атрибуты являются метаинформацией и хранятся в памяти мастер-сервера Кипариса, поэтому общий объем пользовательских атрибутов не должен превышать сотни мегабайт.

{% endnote %}

## Как атрибуты хранятся в системе { #how_stored }

Системные атрибуты могут храниться различными способами, зависящими от типа объекта. Они могут не храниться, а рассчитываться во время вычислений. Пользовательские атрибуты хранятся в виде словаря ключ-значение. Значение закодировано в виде YSON, поэтому обращение к значению атрибута требует распаковки.

```bash
yt set //tmp/@my_attribute '{x=10; y=["hello"; "world"]}'
yt get //tmp/@my_attribute/x
10
yt get //tmp/@my_attribute/y/1
"world"

yt set //tmp/@my_attribute/y/@inner_attribute attr
yt get //tmp/@my_attribute/y/@inner_attribute
"attr"
```

## Примеры { #examples }

```bash
# Получение всех атрибутов объекта
yt get //tmp/@
{
  "creation_time" = "2013-12-06T19:00:48.256444Z";
  "locks" = [];
 ...
}

# Получение конкретного атрибута объекта
yt get //tmp/@type
"map_node"

# Установка конкретного атрибута объекта
yt set //tmp/@my_attribute "my_value"

# Удаление атрибута
yt remove //tmp/@my_attribute

# создание таблицы
echo '{"a": 10, "b": "hello"}' | yt write //tmp/my_table --format json

# Получение первого чанка таблицы
yt get //tmp/my_table/@chunk_ids/0
"3ab1-cd56f-3ec0064-c8998820"

# Удаление таблицы
yt remove //tmp/my_table --force


# Запрос списка с атрибутами
yt list / --attribute type --format '<format=pretty>yson'
[
    <
        "type" = "map_node"
    > "home";
    <
        "type" = "map_node"
    > "kiwi";
   ....
]
```

## Атрибуты на путях { #path_attr }

Популярным сценарием использования атрибутов является аннотирование пути к таблицам и файлам при задании запросов. Подробную информацию можно найти в разделах [Настройки операций](../../../user-guide/data-processing/operations/operations-options.md#path_attributes) и [YPath](../../../user-guide/storage/ypath.md#known_attributes).
